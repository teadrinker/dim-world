


gGui = nil
api valueToColor = func v { type(v) == 'string' ? v : '#'..grayToHex(v) }

#####

api spineComp_createUiContext = func ns, args, returnVal, rootCtx {
	isRootContext = ns == nil
	obj = createComposite()
	drawContext = (isRootContext ?
	         gGui.getRootDrawContext() : 
			 gGui.createLocalDrawContext(gGui.getRootDrawContext())) // note: need namespace search to support more than 1 level, but code not used anyway
	wrapObj = { ___class = 'uiContext', drawContext = drawContext }
	if isRootContext {
		return wrapObj
	} 

	// untested / unfinished
	rv = create(wrapObj)
	obj.add(spineBlock_nameSpaceWriteObj(ns, 'currentUiContext', rv, true))
	obj.add(ns.getContext().runSubLines(ns,ns))
	return obj
}



#####


// a lot of duplicated code, solutions:
//    option 1: wrap coordCtx creation + bindUpdateFunction into a new wrapper? (+ separate solution for drag)
//    option 2: use createUIElement?
//    option 3: we might want to make direct manipulation a more explicit thing in the system (with its own new api)

api spineComp_createUiPoint = func defRadius {

func ns, args, returnVal {
	_this = {}

	trace(spine, 'uiPoint created')

	hookCtx = createHookContext()
	rvCoordCtx = create(uninitialized)
	coordCtxNsHook = spineBlock_hookToNameSpace(hookCtx, ns, 'currentUiContext', rvCoordCtx)
	coordCtx = nil
	hook(hookCtx, rvCoordCtx, func {
		coordCtxWrapper = get(rvCoordCtx)
		if coordCtxWrapper != uninitialized {
			assert(type(coordCtxWrapper),'==','table')
			assert(coordCtxWrapper.___class,'==','uiContext')
			coordCtx = coordCtxWrapper.drawContext
			assert(type(coordCtx),'==','table')
			assert(type(coordCtx.getInputFuzzMargin),'==','func')		

			// todo/fix? this assumes single global currentUiContext that never changes...
		}
	}, true)

	inputHandle = gGui.inputAddDragListener(_this)
	
	ppos = [0,0]

	posInputValid = false
	lastDragMyPosIS = nil
	lastDragInputIS = nil	
	dragging = false
	posIS = [0,0]
	validateISCoord = func { posIS = coordCtx.toInput (ppos) ; posInputValid = true } 
	radIS = 0
	radISAndFuzzSq = 0
	inputTest = func id, pos {
		if not dragging {
			if not posInputValid { validateISCoord() }
			return inputHitTestPointToPoint(pos, posIS, radISAndFuzzSq, radIS)
		}
	}

	drag = create(false) // out

	drwPoint = coordCtx.createDrawable()
	drwLine = nil
	drwLine = coordCtx.createDrawable()

	mCol = spine_createValueConnection(args, 'color', {def = '#FFF'}, func mCol {
		drwPoint.needDraw()
		drwLine.needDraw()
	})

	mRadius = spine_createValueConnection(args, 'radius', {def = defRadius}, func mRadius {
		radIS = coordCtx.toInputScalar(mRadius.get())
		radISAndFuzzSq = square(radIS + coordCtx.getInputFuzzMargin())
		drwPoint.needDraw()
		drwLine.needDraw()
	})

	prevFrame = -1
	mPos = spine_createVec2Conn(args, 'pos', {def = [400,400]}, func mPos { 

		ppos = mPos.get()
		posInputValid = false
		// print(" " ..ppos[0].." "..ppos[1])
		if dragging {
			drwLine.needDraw()
			ppos = coordCtx.fromInput(lastDragMyPosIS)

			// if position was changed while we are dragging/holding
			// reset the position to match mouse/touch position
			// but only do this once per frame (as a new position might be pushed back again)
			//
			// fragile impl, can break depending on callback timing (x vs y), we need some kind of queue priority
			// globally : do somthing like: flush events -> mPos.set(ppos) (+ similar ui stuff, on separate queue?) ->  flush events
			//
			if prevFrame != frameCount() { 
				mPos.set(ppos) 
			}
		}
		drwPoint.needDraw()
		prevFrame = frameCount()
	})	

	drawBindings = nil
	if drwPoint {
		drawBindings = coordCtx.bindUpdateFunction([drwPoint, drwLine], func {
			dataPos = mPos.get()
			rad = mRadius.get()
			drwPoint.update('circle', {x = dataPos[0], y = dataPos[1], radius = rad + (dragging ? min(4, 2 * rad) : 0), color = valueToColor(mCol.get()) })
			drwLine.update('line', dragging ?
				{x1 = ppos[0], y1 = ppos[1], x2=dataPos[0] , y2 = dataPos[1], color = valueToColor(mCol.get()), opacity = 0.5, width = rad } : nil)
		})	
		drwPoint.needDraw()
	}

	inputDrag = func id, event, pos {

		if not posInputValid { validateISCoord() }
		if      event == 'start' { ppos = mPos.get() ; posInputValid = false; dragging = true  ; set(drag, true)  ; drwLine.needDraw() }
		else if event == 'stop'  { ppos = mPos.get() ; posInputValid = false; dragging = false ; set(drag, false) ; drwLine.needDraw() }
		else {
			// print("drag " .. frameCount())

			diffDragIS = v2sub(pos, lastDragInputIS)
			diffMyIS = v2sub(posIS, lastDragMyPosIS)
			ppos = v2add(ppos, coordCtx.fromInputScaleOnly(v2sub(diffDragIS, diffMyIS)))
			validateISCoord()
			if drwPoint { drwPoint.needDraw() }
			if dragging and drwLine { drwLine.needDraw() }
//			set(rvPos, ppos)
			mPos.set(ppos)
		}
		lastDragMyPosIS = posIS
		lastDragInputIS = pos
	}

	_this.inputTest = inputTest
	_this.inputDrag = inputDrag
	_this.remove = func {
		trace(spine, 'uiPoint deleted')
		remove(hookCtx)
		remove(coordCtxNsHook)
		remove(inputHandle)
		remove(drawBindings) // this also removes the drawables
	}

	return _this
}

}

#####

api spineComp_createUiRect = func isBox { // box uses center position

func ns, args, returnVal {

	_this = {}

	trace(spine, 'uiRect created')

	drwRect = { remove = func {}, needDraw = func {} }
	coordCtx = nil


	inputHandle = gGui.inputAddDragListener(_this)
	

	ppos = [0,0]
	posInputValid = false
	lastDragMyPosIS = nil
	lastDragInputIS = nil
	dragging = false

	drag = create(false) // out
	prevFrame = -1


	mCol = spine_createValueConnection(args, 'color', {def = '#FFF'}, func mCol {
		drwRect.needDraw()
	})

	mPos = spine_createVec2Conn(args, 'pos', {def = [400,400]}, func mPos { 
		ppos = mPos.get()
		posInputValid = false
		if dragging {
			ppos = coordCtx.fromInput(lastDragMyPosIS)	
			if prevFrame != frameCount() {					
				mPos.set(ppos)
			}
			drwRect.needDraw()
			posInputValid = false
		}
		drwRect.needDraw()
		prevFrame = frameCount()
	})	

	mSize = spine_createVec2Conn(args, 'size', {def = [100,100]}, func mSize { 
		drwRect.needDraw()
	})	

	posIS = [0,0]
	validateISCoord = func { posIS = coordCtx.toInput (ppos) ; posInputValid = true } 

	drawBindings = nil
	hookCtx = createHookContext()
	rvCoordCtx = create(uninitialized)
	coordCtxNsHook = spineBlock_hookToNameSpace(hookCtx, ns, 'currentUiContext', rvCoordCtx)
	hook(hookCtx, rvCoordCtx, func {
		remove(drawBindings)
		coordCtxWrapper = get(rvCoordCtx)
		if coordCtxWrapper != uninitialized {
			assert(type(coordCtxWrapper),'==','table')
			assert(coordCtxWrapper.___class,'==','uiContext')
			coordCtx = coordCtxWrapper.drawContext
			assert(type(coordCtx),'==','table')
			assert(type(coordCtx.getInputFuzzMargin),'==','func')		


			drwRect = coordCtx.createDrawable()
			drawBindings = coordCtx.bindUpdateFunction([drwRect], func {
				tmpSize = mSize.get()
				tmpPos = mPos.get()
				if isBox {
					// box uses center position
					tmpPos[0] = tmpPos[0] - tmpSize[0]/2
					tmpPos[1] = tmpPos[1] - tmpSize[1]/2
				}
				drwRect.update('rect', {x = tmpPos[0], y = tmpPos[1], w=tmpSize[0], h=tmpSize[1], color = valueToColor(mCol.get()) })
			})	
			drwRect.needDraw()

		}
	}, true)

	inputTest = func id, pos {
		if not dragging {
			if not posInputValid { validateISCoord() }
			size = mSize.get()
			margin = coordCtx.getInputFuzzMargin()

			// polygon check instead of rect - we want to support rotated and 3D perspective transforms

			dist = nil

			if isBox {
				quad1 = coordCtx.toInput([ppos[0] - size[0]/2, ppos[1] - size[0]/2])
				quad2 = coordCtx.toInput([ppos[0] + size[0]/2, ppos[1] - size[0]/2])
				quad3 = coordCtx.toInput([ppos[0] + size[0]/2, ppos[1] + size[1]/2])
				quad4 = coordCtx.toInput([ppos[0] - size[0]/2, ppos[1] + size[1]/2])
				dist = distToQuad(pos[0], pos[1], margin, quad1[0], quad1[1], quad2[0], quad2[1], quad3[0], quad3[1], quad4[0], quad4[1])
			} else {
				quad2 = coordCtx.toInput([ppos[0] + size[0], ppos[1]])
				quad3 = coordCtx.toInput([ppos[0] + size[0], ppos[1] + size[1]])
				quad4 = coordCtx.toInput([ppos[0], ppos[1] + size[1]])
				dist = distToQuad(pos[0], pos[1], margin, posIS[0], posIS[1], quad2[0], quad2[1], quad3[0], quad3[1], quad4[0], quad4[1])
			}
			if dist != nil {
				// reduce priority of large rects (good for touch input vs small items)
				// definition of small is hardoded: 30 units
				dist = dist + 0.5 * margin * (1 - min(1, 30 / max(size[0], size[1])))
			}
			return dist
		}
	}

	inputDrag = func id, event, pos {
		if not posInputValid { validateISCoord() }
		if      event == 'start' { ppos = mPos.get() ; posInputValid = false; dragging = true  ; set(drag, true) }
		else if event == 'stop'  { ppos = mPos.get() ; posInputValid = false; dragging = false ; set(drag, false)}
		else {


			diffDragIS = v2sub(pos, lastDragInputIS)
			diffMyIS = v2sub(posIS, lastDragMyPosIS)
			ppos = v2add(ppos, coordCtx.fromInputScaleOnly(v2sub(diffDragIS, diffMyIS)))
			validateISCoord()
			if drwRect { drwRect.needDraw() }

//			set(rvPos, ppos)
			mPos.set(ppos)
		}
		lastDragMyPosIS = posIS
		lastDragInputIS = pos
	}

	_this.inputTest = inputTest
	_this.inputDrag = inputDrag
	_this.remove = func {
		trace(spine, 'uiRect deleted')
		remove(hookCtx)
		remove(coordCtxNsHook)
		remove(inputHandle)
		remove(drawBindings) // also removes drwRect
	}
	

	return _this
}
}

#####


// arg names?
//   0,1       
//   from, to
//   p1, p2
//   pos, pos2
//   pos, end

api spineComp_line = func ns, args, returnVal {
	
	createUIElement({
		position = [0, 0]
		hitInput = 'circle'
		draggable = true
		onInit = func self, ctx {
			line = ctx.createDrawable()
			mFrom = spine_createVec2Conn       (args, 'from' , {def = [370,370] }, func { if line { line.needDraw() } })
			mTo   = spine_createVec2Conn       (args, 'to'   , {def = [430,430] }, func { if line { line.needDraw() } })
			mCol  = spine_createValueConnection(args, 'color', {def = '#FFF'  }, func { if line { line.needDraw() } })
			mWidth= spine_createValueConnection(args, 'width', {def = 1         }, func { if line { line.needDraw() } })
			self.bindDrawables([line], func {
				v1 = mFrom.get()
				v2 = mTo.get()
				line.update('line', {x1 = v1[0], y1 = v1[1], x2=v2[0] , y2 = v2[1], color = valueToColor(mCol.get()), width = mWidth.get() })
			})
			line.needDraw()
			return {
				onRemove = func {
					remove(mFrom)	
					remove(mTo)	
					remove(mCol)	
					remove(mWidth)				
				}
			}			
		}
	})

}

#####

api defaultBackgroundColor = '#333'

api spineComp_background = func ns, args, returnVal {
	set(returnVal, uninitialized)
	handle = spine_createValueConnection(args, 0, {def = 0}, func v0 {
		v = v0.get()
		t = type(v)
		gGui.setBackgroundColor(t == 'string' or t == 'number' ? valueToColor(v) : defaultBackgroundColor)	
	})	
	return { remove = func { remove(handle) ; gGui.setBackgroundColor(defaultBackgroundColor) }}
}


#####

global projectTitle = 'Spine - Live Demo'

guiContext = createGuiContext()
gGui = createSimpleGuiSystem(guiContext.getBasicDraw())
gGui.setBackgroundColor(defaultBackgroundColor)

updateUiScale = func { gGui.setDPI(getSystemDPI()) }
updateUiScale() 

rvResize = create([getPageWidth(), getPageHeight()])
guiContext.onResize(func {
	// print('resize dpi:'..getSystemDPI())
	updateUiScale()
	set(rvResize, [getPageWidth(), getPageHeight()])
	gGui.draw()
})

urlConfig = uriToTable(getURLQueryString())

createSpineApp({

	debug           = urlConfig.debug == '1'
	incremental     = urlConfig.incremental == nil ? true : urlConfig.incremental == '1'
	hideCode        = urlConfig.hidecode == '1'
	fontSize        = urlConfig.fontsize ? toNumber(urlConfig.fontsize) : nil
	embed           = urlConfig.embed == '1'

	code            = '\n\nrun\n  point pos = [400, 400]'
	pageSize        = rvResize
	paneBackground  = draggableDividerAndBackground
	isAnyDown       = gGui.isAnyDown

// todo offset draw area based on pane position
//	onChangedPane   = func paneExtent { gGui.getRootDrawContext().setOffset(paneExtent) } 

	onRun = func app, block {
		guiComponents = app.injectComponents(block, {
			uiContext        = spineComp_createUiContext
			point            = spineComp_createUiPoint(6)
			circle           = spineComp_createUiPoint(50)
			rect             = spineComp_createUiRect()
			box              = spineComp_createUiRect(true)
			line             = spineComp_line
			background       = spineComp_background
			rgb              = wrap4NumberToString(func x,y,z,w { '#'..rgbToHex(x,y,z,w) },[uninitialized, uninitialized, uninitialized, 1])
			hsv              = wrap4NumberToString(func x,y,z,w { '#'..hsvToHex(x,y,z,w) },[uninitialized, 1, 1, 1])
			hsl              = wrap4NumberToString(func x,y,z,w { '#'..hslToHex(x,y,z,w) },[uninitialized, 1, 0.5, 1])
		})
		guiComponents.add(spineBlock_nameSpaceWriteObj(block, 'currentUiContext', create(spineComp_createUiContext())))
	}
})