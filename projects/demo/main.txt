


gGui = nil


#####

api spineComp_createUiContext = func ns, args, returnVal, rootCtx {
	obj = createComposite()
	drawContext = gGui.createLocalDrawContext()
	wrapObj = { ___class = 'uiContext', drawContext = drawContext }
	if ns == nil {
		return wrapObj
	} 

	rv = create(wrapObj)
	obj.add(spineBlock_nameSpaceWriteObj(ns, 'currentUiContext', rv, true))
	obj.add(ns.getContext().runSubLines(ns,ns))
	return obj
}

#####


// a lot of duplicated code, solutions:
//    option 1: wrap coordCtx creation + bindUpdateFunction into a new wrapper? (+ separate solution for drag)
//    option 2: put shared code in createDraggableUiElement() - might grow to something ugly over time, I prefer 1...

api spineComp_createUiPoint = func ns, args, returnVal {
	_this = {}

	trace(spine, 'uiPoint created')

	hookCtx = createHookContext()
	rvCoordCtx = create(uninitialized)
	coordCtxNsHook = spineBlock_hookToNameSpace(hookCtx, ns, 'currentUiContext', rvCoordCtx)
	coordCtx = nil
	hook(hookCtx, rvCoordCtx, func {
		coordCtxWrapper = get(rvCoordCtx)
		if coordCtxWrapper != uninitialized {
			assert(type(coordCtxWrapper),'==','table')
			assert(coordCtxWrapper.___class,'==','uiContext')
			coordCtx = coordCtxWrapper.drawContext
			assert(type(coordCtx),'==','table')
			assert(type(coordCtx.getInputFuzzMargin),'==','func')		

			// todo/fix? this assumes single global currentUiContext that never changes...
		}
	}, true)



	inputHandle = gGui.inputAddDragListener(_this)
	
	ppos = [0,0]
	posInputValid = false
	lastDragMyPosIS = nil
	lastDragInputIS = nil
	dragging = false

	drag = create(false) // out

	drwPoint = coordCtx.createDrawable()
	drwLine = nil
	drwLine = coordCtx.createDrawable()

	mCol = spine_createValueConnection(args, 'color', {def = '#FFF'}, func mCol {
		drwPoint.needDraw()
		drwLine.needDraw()
	})

	mRadius = spine_createValueConnection(args, 'radius', {def = 6}, func mRadius {
		drwPoint.needDraw()
		drwLine.needDraw()
	})

	prevFrame = -1
	mPos = spine_createVec2Conn(args, 'pos', {def = [400,400]}, func mPos { 

		ppos = mPos.get()
		posInputValid = false
		// print(" " ..ppos[0].." "..ppos[1])
		if dragging {
			drwLine.needDraw()
			ppos = coordCtx.fromInput(lastDragMyPosIS)

			// if position was changed while we are dragging/holding
			// reset the position to match mouse/touch position
			// but only do this once per frame (as a new position might be pushed back again)
			//
			// fragile impl, can break depending on callback timing (x vs y), we need some kind of queue priority
			// globally : do somthing like: flush events -> mPos.set(ppos) (+ similar ui stuff, on separate queue?) ->  flush events
			//
			if prevFrame != frameCount() { 
				mPos.set(ppos) 
			}
		}
		drwPoint.needDraw()
		prevFrame = frameCount()
	})	

	posIS = [0,0]
	validateISCoord = func { posIS = coordCtx.toInput (ppos) ; posInputValid = true } 

	inputTest = func id, pos {
		if not dragging {
			if not posInputValid { validateISCoord() }
			return inputHitTestPointToPoint(pos, posIS, square(coordCtx.getInputFuzzMargin()))
		}
	}

	drawBindings = nil
	if drwPoint {
		drawBindings = coordCtx.bindUpdateFunction([drwPoint, drwLine], func {
			dataPos = mPos.get()
			rad = mRadius.get()
			drwPoint.update('circle', {x = dataPos[0], y = dataPos[1], radius = rad * (dragging ? 1.8 : 1), col = mCol.get() })
			drwLine.update('line', dragging ?
				{x1 = ppos[0], y1 = ppos[1], x2=dataPos[0] , y2 = dataPos[1], col = mCol.get(), opacity = 0.5, width = rad } : nil)
		})	
		drwPoint.needDraw()
	}

	inputDrag = func id, event, pos {

		if not posInputValid { validateISCoord() }
		if      event == 'start' { ppos = mPos.get() ; posInputValid = false; dragging = true  ; set(drag, true)  ; drwLine.needDraw() }
		else if event == 'stop'  { ppos = mPos.get() ; posInputValid = false; dragging = false ; set(drag, false) ; drwLine.needDraw() }
		else {
			// print("drag " .. frameCount())

			diffDragIS = v2sub(pos, lastDragInputIS)
			diffMyIS = v2sub(posIS, lastDragMyPosIS)
			ppos = v2add(ppos, coordCtx.fromInputScalar(v2sub(diffDragIS, diffMyIS)))
			validateISCoord()
			if drwPoint { drwPoint.needDraw() }
			if dragging and drwLine { drwLine.needDraw() }
//			set(rvPos, ppos)
			mPos.set(ppos)
		}
		lastDragMyPosIS = posIS
		lastDragInputIS = pos
	}

	_this.inputTest = inputTest
	_this.inputDrag = inputDrag
	_this.remove = func {
		trace(spine, 'uiPoint deleted')
		remove(hookCtx)
		remove(coordCtxNsHook)
		remove(inputHandle)
		remove(drawBindings) // this also removes the drawables
	}
	

	return _this
}

#####

api spineComp_createUiRect = func ns, args, returnVal {

	_this = {}

	trace(spine, 'uiRect created')

	drwRect = { remove = func {}, needDraw = func {} }
	coordCtx = nil


	inputHandle = gGui.inputAddDragListener(_this)
	

	ppos = [0,0]
	posInputValid = false
	lastDragMyPosIS = nil
	lastDragInputIS = nil
	dragging = false

	drag = create(false) // out
	prevFrame = -1


	mCol = spine_createValueConnection(args, 'color', {def = '#FFF'}, func mCol {
		drwRect.needDraw()
	})

	mPos = spine_createVec2Conn(args, 'pos', {def = [400,400]}, func mPos { 
		ppos = mPos.get()
		posInputValid = false
		if dragging {
			ppos = coordCtx.fromInput(lastDragMyPosIS)	
			if prevFrame != frameCount() {					
				mPos.set(ppos)
			}
			drwRect.needDraw()
			posInputValid = false
		}
		drwRect.needDraw()
		prevFrame = frameCount()
	})	

	mSize = spine_createVec2Conn(args, 'size', {def = [100,100]}, func mSize { 
		drwRect.needDraw()
	})	

	posIS = [0,0]
	validateISCoord = func { posIS = coordCtx.toInput (ppos) ; posInputValid = true } 

	drawBindings = nil
	hookCtx = createHookContext()
	rvCoordCtx = create(uninitialized)
	coordCtxNsHook = spineBlock_hookToNameSpace(hookCtx, ns, 'currentUiContext', rvCoordCtx)
	hook(hookCtx, rvCoordCtx, func {
		remove(drawBindings)
		coordCtxWrapper = get(rvCoordCtx)
		if coordCtxWrapper != uninitialized {
			assert(type(coordCtxWrapper),'==','table')
			assert(coordCtxWrapper.___class,'==','uiContext')
			coordCtx = coordCtxWrapper.drawContext
			assert(type(coordCtx),'==','table')
			assert(type(coordCtx.getInputFuzzMargin),'==','func')		


			drwRect = coordCtx.createDrawable()
			drawBindings = coordCtx.bindUpdateFunction([drwRect], func {
				tmpSize = mSize.get()
				tmpPos = mPos.get()
				drwRect.update('rect', {x = tmpPos[0], y = tmpPos[1], w=tmpSize[0], h=tmpSize[1], col = mCol.get() })
			})	
			drwRect.needDraw()

		}
	}, true)

	inputTest = func id, pos {
		if not dragging {
			if not posInputValid { validateISCoord() }
			size = mSize.get()
			margin = coordCtx.getInputFuzzMargin()

			// polygon check instead of rect - we want to support rotated and 3D perspective transforms
			quad2 = coordCtx.toInput([ppos[0] + size[0], ppos[1]])
			quad3 = coordCtx.toInput([ppos[0] + size[0], ppos[1] + size[1]])
			quad4 = coordCtx.toInput([ppos[0], ppos[1] + size[1]])
			dist = distToQuad(pos[0], pos[1], margin, posIS[0], posIS[1], quad2[0], quad2[1], quad3[0], quad3[1], quad4[0], quad4[1])
			if dist != nil {
				// reduce priority of large rects (good for touch input vs small items)
				// definition of small is hardoded: 30 units
				dist = dist + 0.5 * margin * (1 - min(1, 30 / max(size[0], size[1])))
			}
			return dist
		}
	}

	inputDrag = func id, event, pos {
		if not posInputValid { validateISCoord() }
		if      event == 'start' { ppos = mPos.get() ; posInputValid = false; dragging = true  ; set(drag, true) }
		else if event == 'stop'  { ppos = mPos.get() ; posInputValid = false; dragging = false ; set(drag, false)}
		else {
			diffDragIS = v2sub(pos, lastDragInputIS)
			diffMyIS = v2sub(posIS, lastDragMyPosIS)
			ppos = v2add(ppos, coordCtx.fromInputScalar(v2sub(diffDragIS, diffMyIS)))
			validateISCoord()
			if drwRect { drwRect.needDraw() }
//			set(rvPos, ppos)
			mPos.set(ppos)
		}
		lastDragMyPosIS = posIS
		lastDragInputIS = pos
	}

	_this.inputTest = inputTest
	_this.inputDrag = inputDrag
	_this.remove = func {
		trace(spine, 'uiRect deleted')
		remove(hookCtx)
		remove(coordCtxNsHook)
		remove(inputHandle)
		remove(drawBindings) // also removes drwRect
	}
	

	return _this
}


#####


global projectTitle = 'Spine - Live Demo'

guiContext = createGuiContext()
gGui = createSimpleGuiSystem(guiContext.getBasicDraw())

updateUiScale = func { gGui.setDPI(getSystemDPI()) }
updateUiScale() 

rvResize = create([getPageWidth(), getPageHeight()])
guiContext.onResize(func {
	// print('resize dpi:'..getSystemDPI())
	updateUiScale()
	set(rvResize, [getPageWidth(), getPageHeight()])
	gGui.draw()
})


createSpineApp({
	code = '\n\nrun\n  point pos = [400, 400]'
	pageSize = rvResize
	isDragging = gGui.isDragging
	onRun = func app, block {
		guiComponents = app.injectComponents(block, {
			uiContext        = spineComp_createUiContext
			point            = spineComp_createUiPoint
			rect             = spineComp_createUiRect
		})
		guiComponents.add(spineBlock_nameSpaceWriteObj(block, 'currentUiContext', create(spineComp_createUiContext())))
	}
})