
// enable logging from querystring
if gParserContext != nil {
	logField = uriToTable(getURLQueryString()).log
	if type(logField) == 'string' {
		for v in split(logField, ',') {
			gParserContext.enableTrace(v, true)
		}
	}
}

#####

////////////////////////////////////////////////////////// JAVASCRIPT BACKEND



#{ js return { isValidNumber : function(v)    { return typeof v === 'number' && !Number.isNaN(v) } } #}   #####
#{ js return { isFiniteNumber : function(v)   { return typeof v === 'number' && Number.isFinite(v) } } #}   #####
#{ js return { toString   : function(s,radix) { return s.toString(radix) } } #}   #####
#{ js return { toNumber   : function(s)       { return parseFloat(s)     } } #}   #####
#{ js return { sorted     : function(a, f)    { if(f && a.length > 1) { var tmp = f(a[0],a[1]) ; if(typeof tmp !== 'number') throw('sorted incorrect sortingfunc')      } return a.slice(0).sort(f)} } #}   #####
#{ js return { sortInPlace: function(a, f)    { if(f && a.length > 1) { var tmp = f(a[0],a[1]) ; if(typeof tmp !== 'number') throw('sortInPlace incorrect sortingfunc') } return a.sort(f)         } } #}   #####

#####

#{ js return { empty      : function(o) { 
			if(typeof o != 'object') { throw('empty() noimpl '+(typeof o)) }
			if(!o.splice) {
				for(var k in o) {
					if(o[k] !== undefined) {
						return false
					}
				}				
			} else if(a.length !== 0) {
				return  false
			}
			return true 
		} 
	} 
#}   

#####

#{ js return { substring: function(s, i1, i2) {  // support negative values for i1/i2?  substring("abcd", 1, -1) == "bc"
	if(typeof s != 'string') { throw("substring() not a string but " + (typeof s) + " " + s) }
	return s.substring(i1 < 0 ? (i1 + s.length) : i1, i2 < 0 ? (i2 + s.length) : i2 )
} } #}  

#####

#{ js return { subarray: function(a, i1, i2) {  // support negative values for i1/i2?  subarray([1,2,3], -2, -1) == [2,3]
	if(typeof a != 'object' || !a.splice) { throw("subarray() not a array but " + (typeof a) + " " + a) }
	return a.slice(i1, i2)
} } #}  

#####

#{ js
	return {
		AesEncrypt : function(plaintext, password, nBits) { return Aes.Ctr.encrypt(plaintext, password, nBits) } ,
		AesDecrypt : function(plaintext, password, nBits) { return Aes.Ctr.decrypt(plaintext, password, nBits) }
	}
#}

#####

#{ js

	// based on pnpoly http://www.ecse.rpi.edu/Homepages/wrf/Research/Short_Notes/pnpoly.html
	insidePolygon = function(verts, testx, testy)
	{
	  var i, j, c = false, nvert = verts.length
	  for (i = 0, j = nvert-1; i < nvert; j = i++) {
	    if ( ((verts[i].y>testy) != (verts[j].y>testy)) &&
		 (testx < (verts[j].x-verts[i].x) * (testy-verts[i].y) / (verts[j].y-verts[i].y) + verts[i].x) )
	       c = !c;
	  }
	  return c;
	}


	// http://stackoverflow.com/questions/849211/shortest-distance-between-a-point-and-a-line-segment
	function distToNearestPointOnLineSegment(x, y, x1, y1, x2, y2) {

	  var A = x - x1;
	  var B = y - y1;
	  var C = x2 - x1;
	  var D = y2 - y1;

	  var dot = A * C + B * D;
	  var len_sq = C * C + D * D;
	  var param = -1;
	  if (len_sq != 0) //in case of 0 length line
	      param = dot / len_sq;

	  var xx, yy;

	  if (param < 0) {
	    xx = x1;
	    yy = y1;
	  }
	  else if (param > 1) {
	    xx = x2;
	    yy = y2;
	  }
	  else {
	    xx = x1 + param * C;
	    yy = y1 + param * D;
	  }

	  var dx = x - xx;
	  var dy = y - yy;
	  return Math.sqrt(dx * dx + dy * dy);
	}


	var distToQuad = function(x, y, boundReject, x1,y1, x2,y2, x3,y3, x4,y4) {
		if(x < x1-boundReject && x < x2-boundReject && x < x3-boundReject && x < x4-boundReject ||
			x > x1+boundReject && x > x2+boundReject && x > x3+boundReject && x > x4+boundReject ||
			y < y1-boundReject && y < y2-boundReject && y < y3-boundReject && y < y4-boundReject ||
			y > y1+boundReject && y > y2+boundReject && y > y3+boundReject && y > y4+boundReject) {
		return 
		}
		var p = [{x:x1, y:y1}, {x:x2, y:y2}, {x:x3, y:y3}, {x:x4, y:y4}]
		var lastI = p.length-1
		var minDist = distToNearestPointOnLineSegment(x,y,p[lastI].x,p[lastI].y,p[0].x,p[0].y)
		for(var i = 0; i < lastI; i++) {
			var dist = distToNearestPointOnLineSegment(x,y,p[i].x,p[i].y,p[i+1].x,p[i+1].y)
			if(dist < minDist) { minDist = dist}
		}
		if(insidePolygon(p, x, y)) { minDist = -minDist }
		return minDist < boundReject ? minDist : undefined
	}

	// https://madtealab.com/#C=1&F=1&G=1&W=735&GW=681&GH=262&GX=-0.1128016708632485&GY=0.3542917079424275&GS=0.8988871279278483&GQ=90&EH=168&a=0.37777777777777777&aMi=-2&aMa=2&f1=xx%28x%2C+y%2C+a%2C+p%5B0%5D.x%2C+p%5B0%5D.y%2C+p%5B1%5D.x%2C+p%5B1%5D.y%2C+p%5B2%5D.x%2C+p%5B2%5D.y%2C+p%5B3%5D.x%2C+p%5B3%5D.y%29&fs1=25&p=%5B0.83%2C-0.153%2C0.496%2C0.65%2C-0.505%2C0.91%2C-1.069%2C0.19%2C%5D&Expr=%0A%2F%2F+paste+here%0A%0A%0Axx+%3D+distToQuad

	return {
		distToQuad : distToQuad
	}
#}

#####

api getKeys = func t { out = [] ; tt = type(t) ; if tt == 'table' or tt == 'array' { for k,v in t { push(out, k) } }  out }

#####

////////////////////////////////////////////////////////// GENERIC

api findAndReplace = func s, find, repl { join(split(s, find), repl) }

#####   api pi = 3.141592653589793238462643383279502884197
#####	api square = func x { x*x }
#####   api mix = func a, b, t { a + t * (b - a) } 
#####   api isArray  = func a { type(a) == 'array' }  // js opt with generic fallback somehow?
#####   api isTable  = func a { type(a) == 'table' }  // js opt with generic fallback somehow?
#####   api isNumber = func a { type(a) == 'number' } // js opt with generic fallback somehow?
#####   api isString = func a { type(a) == 'string' } // js opt with generic fallback somehow?
#####

api linearstep = func a, b, x { 
    if x<=a { return 0 }
    if x>=b { return 1 }
	return (x-a) / (b-a)
}

#####

api smoothstep = func a, b, x  {  
    if x<=a { return 0 }
    if x>=b { return 1 }
    x = (x-a) / (b-a)
    return x*x*(3.0-2.0*x)
}

#####

api smootherstep = func a, b, x { 
    if x<=a { return 0; }
    if x>=b { return 1; }
    x = (x-a) / (b-a)
    return x*x*x*(x*(x*6 - 15) + 10)
}	

#####

// api empty = func o {
// 	assert(type(o), '==', 'table')  // need array support?
// 	for _, __ in o { return false }  return in for IS UNSUPPORTED!
// 	true
// }


api map = func f, o {
	r = nil
	if type(o) == 'array' { r = [] ; resize(r, len(o)) }
	else { r = {} }
	for k, v in o { r[k] = f(v) }
	r
}

 // api map = func f, o { r = newOf(o) ; for k, v in o { r[k] = f(v) } ; r }
#####

api mapKV = func f, o {
	r = nil
	if type(o) == 'array' { r = [] ; resize(r, len(o)) }
	else { r = {} }
	for k, v in o { r[k] = f(k, v) }
	r
}

#####

// haskell style reduce, I think placing the array/object as first arg rather than last would be more readable

api fold = func f, initial, o {
	firstIt = {}
	val = initial == nil ? firstIt : initial
	for k, v in o {
		if val == firstIt {
			val = v
		} else {
			val = f(val, v, k, o) 		
		}
	}
	val
}


#####

api range = func a,b,c{
	r = []
	if b == nil {
		resize(r, a)
		for i * a { r[i] = i }
	} else { // if c == nil {
		throw('range todo')
	}
	r
}
#####

api newOf = func o {
	r = nil
	if type(o) == 'array' { r = [] ; resize(r, len(o)) }
	else { r = {} }
	r
}


#####

api copy = func src {
	t = type(src)
	if t == 'array' {
		return subarray(src, 0)
	} else if t == 'table' {
		out = {}
		for k,v in src {
			out[k] = v
		} 
		;return out
	}
	src // no copy needed
}

#####

api deepcopy = nil
api deepcopy = func src {
	out = src
	t = type(src)
	if t == 'array' {
		out = []
		leng = len(src)
		resize(out, leng)
		for i * leng { out[i] = deepcopy(src[i]) }
	} else if t == 'table' {
		out = {}
		for k,v in src {
			out[k] = deepcopy(v)
		} 
	}
	return out
}


#####

api isInt = func v { type(v) == 'number' and v == floor(v) and true or false }

#####

// iterator function should pass the value as parameter,
// but api forEach (for k,v in ...) passes key as the only parameter

api selectUsing = func forEachFunc, o, f { out = [] ; forEachFunc(o, func i { tmp = f(i) ; if tmp { push(out, tmp) } } ) ; out }

//  selectUsing == mapAndFilterNil

#####

api mapFrom     = func forEachFunc, o, f { out = [] ; forEachFunc(o, func i {                       push(out, f(i))  } ) ; out }

#####

api extend        = func dst, src { for k,v in src {                    dst[k] = v   } ; dst }    // new js standard called assign()

#####

api tableFallback = func dst, src { for k,v in src { if dst[k] == nil { dst[k] = v } } ; dst }

#####

api immutableUpdate = func org, key, val { r = {} ; for k,v in org { r[k] = v } ; r[key] = val ; r }   // js (org, key, val) => {...org, [key]: val }

#####

api countItems = func t { i = 0 ; for k,v in t { i = i + 1 } ; i }

#####

callWithArgsF = [
	func f    { f() }
	func f, a { f(a[0]) }
	func f, a { f(a[0], a[1]) }
	func f, a { f(a[0], a[1], a[2]) }
	func f, a { f(a[0], a[1], a[2], a[3]) }
	func f, a { f(a[0], a[1], a[2], a[3], a[4]) }
	func f, a { f(a[0], a[1], a[2], a[3], a[4], a[5]) }
	func f, a { f(a[0], a[1], a[2], a[3], a[4], a[5], a[6]) }
	func f, a { f(a[0], a[1], a[2], a[3], a[4], a[5], a[6], a[7]) }
	func f, a { f(a[0], a[1], a[2], a[3], a[4], a[5], a[6], a[7], a[8]) }
	func f, a { f(a[0], a[1], a[2], a[3], a[4], a[5], a[6], a[7], a[8], a[9]) }
	func f, a { f(a[0], a[1], a[2], a[3], a[4], a[5], a[6], a[7], a[8], a[9], a[10]) }
	func f, a { f(a[0], a[1], a[2], a[3], a[4], a[5], a[6], a[7], a[8], a[9], a[10], a[11]) }
	func f, a { f(a[0], a[1], a[2], a[3], a[4], a[5], a[6], a[7], a[8], a[9], a[10], a[11], a[12]) }
	func f, a { f(a[0], a[1], a[2], a[3], a[4], a[5], a[6], a[7], a[8], a[9], a[10], a[11], a[12], a[13]) }
	func f, a { f(a[0], a[1], a[2], a[3], a[4], a[5], a[6], a[7], a[8], a[9], a[10], a[11], a[12], a[13], a[14]) }
	func f, a { f(a[0], a[1], a[2], a[3], a[4], a[5], a[6], a[7], a[8], a[9], a[10], a[11], a[12], a[13], a[14], a[15]) }
	func f, a { f(a[0], a[1], a[2], a[3], a[4], a[5], a[6], a[7], a[8], a[9], a[10], a[11], a[12], a[13], a[14], a[15], a[16]) }
	func f, a { f(a[0], a[1], a[2], a[3], a[4], a[5], a[6], a[7], a[8], a[9], a[10], a[11], a[12], a[13], a[14], a[15], a[16], a[17]) }
	func f, a { f(a[0], a[1], a[2], a[3], a[4], a[5], a[6], a[7], a[8], a[9], a[10], a[11], a[12], a[13], a[14], a[15], a[16], a[17], a[18]) }
	func f, a { f(a[0], a[1], a[2], a[3], a[4], a[5], a[6], a[7], a[8], a[9], a[10], a[11], a[12], a[13], a[14], a[15], a[16], a[17], a[18], a[19]) }
]
api callWithArgs = func f, a { la = len(a) ; assert(len, '<=', 20) ; callWithArgsF[la](f, a) }

##### api getLast = func a    { a[(len(a) - 1)] }
##### api getMiddle = func a  { a[floor(len(a)/2)] }
##### api setLast = func a, v { a[(len(a) - 1)] = v }

##### api number_to_string = func a { '' .. a }

##### api eval = func s { f = textToFunc(s); if f.error { return f } return f.func() }

##### api unserialize = func s {  eval(s) }

##### api pushAndReturn = func a, v { push(a,v) ; v }

##### api fallback = func a, b, c { if a != nil { return a} if b != nil { return b} return c }

##### api formatNice = func sec, m { if sec == 0 { return '0' } m = m ?: (sec < 0.001 ? 1000 : (sec < 0.01 ? 100 : (sec < 0.1 ? 10 : 1) ) ) ; ms = floor(sec*m)/m ; ''..(ms == 0 ? '~0' : ms) }
##### api formatMs   = func sec, m { if sec == 0 { return '0 ms' } m = m ?: (sec < 0.001 ? 1000 : (sec < 0.01 ? 100 : (sec < 0.1 ? 10 : 1) ) ) ; ms = floor(sec*m*1000)/m ; ''..(ms == 0 ? '~0' : ms)..' ms' }

#####
deepIterateArraysRec = nil
deepIterateArraysRec = func ar, f { for k, v in ar { if type(v) == 'array' { deepIterateArraysRec(v, f) } else { f(v) } } }
api deepIterateArrays = func root, f { assert(type(root), '==', 'array') ; deepIterateArraysRec(root, f) }
//api deepArrayForEach = func root, f { assert(type(root), '==', 'array') ; deepIterateArraysRec(root, f) }


#####

// api rep = func s, times { o = '' ; for i = 1, times { o = o .. s } o }   minimal impl size vs speed?

api rep = func s, times {
	if times == nil { throw('rep() got nil') }
	if times < 5 {
		if times == 1 { return s }
		if times == 2 { return s .. s }
		if times == 3 { return s .. s .. s }
		if times == 4 { return s .. s .. s .. s }
		return ''
	}
	o = ''
	for i = 1, 32 {
		if times % 2 != 0 {
			o = o .. s
		}
		s = s .. s
		times = floor(times / 2)
		if times == 0 { break }
	}
	o
}


#####
api serialize = func data, maxDepth, lineFeedDepth, allowMissingTypes, maxTokens {  // any_to_string
	maxDepth = maxDepth or 99999
	maxTokens = maxTokens or 99999999
	indent = 3
	lineFeedDepth = lineFeedDepth or 0
	depth = 0
	a = []
	serializeInner = nil
	serializeInner = func v {
		depth = depth + 1
		if depth >= maxDepth or len(a) >= maxTokens { push(a, '"..."') ; depth = depth - 1 ; return nil }
		t = type(v)
		if t == 'nil'			{ push(a, 'nil') 
		} else if t == 'number'	{ push(a, number_to_string(v) )
//		} else if t == 'string' { push(a, '\"' .. v .. '\"')
		} else if t == 'string' { push(a, toJSON(v))
		} else if t == 'bool'   { push(a, v and 'true' or 'false')
		} else if t == 'table'	{		
															// alert('serializeInner table')
			push(a, '{')
			if depth <= lineFeedDepth { push(a, '\n'..rep(' ',depth*indent)) }
			
			sortK = []
			for k, val in v { push(sortK, k) }
			for _, k in sortInPlace(sortK) { val = v[k]
			
//			for k, val in v { 
			
				push(a, k)        // needs escaping here? work out support for keys with spaces etc
								  // support +flag -flag for bools?
				push(a, ' = ')
				serializeInner(val)
				push(a, ', ')
				if depth <= lineFeedDepth { push(a, '\n'..rep(' ',depth*indent)) }
			}
			if getLast(a) != '{' {
				pop(a) // pop last comma
			}
			push(a, '}')
															// alert('serializeInner table e')			
		} else if t == 'array' {
															// alert('serializeInner array')						
			push(a, '[')
			if depth <= lineFeedDepth { push(a, '\n'..rep(' ',depth*indent)) }
			lastI = len(v) - 1
			for i = 0, lastI {
				serializeInner(v[i])
				if i != lastI {
					push(a, ', ')				
					if depth <= lineFeedDepth { push(a, '\n'..rep(' ',depth*indent)) }
				}
			}
			push(a, ']')
															// alert('serializeInner array e')						
		} else if allowMissingTypes {
			if t == 'func' {
				push(a, '__func')
			} else {
				push(a, '"missing type ' .. t .. '"')
			}
		} else {
			throw('serialize() unknown type ' .. t)
		}
		depth = depth - 1
	}
															// alert('serialize before serializeInner')
	serializeInner(data)
															// alert('serialize arrayConcatToString')
	return arrayConcatToString(a)
}

api aldeb = func data, desc {
	alert((desc or '')..'  '..serialize(data,4,1,true))
}

api toStr = func d, limit {
	if limit == nil { return serialize(d,10,1,true,1000) }
	str = findAndReplace(serialize(d,10,0,true,1000), ' ', '')
	if len(str) < limit { return str }
	return substring(str, 0, limit - 3) .. '...'
}

api toStr2 = func d, maxDepth { return serialize(d,maxDepth == nil ? 2 : maxDepth,1,true,1000) } 

#####

// api remove = func h { if h { h.remove() } }  // rename to delete?  (add "guard" for js keywords such as default and delete)

api remove = func h {
	if h {
		if h.remove == nil {
			print('remove() INTERNAL ERROR h.remove == nil')
			print('remove() INTERNAL ERROR : '..toStr2(h))
		} else if h.__debug_REMOVECALLED {
			print('remove() '..h..' IGNORED!' .. (h.__debug_REMOVECALLEDCOMPLETE ? 'DOUBLE DELETE!' : 'REMOVE REENTRY!'))
	//		throw('remove() '..h..' IGNORED! DOUBLE DELETE!')
	// 		#{ js debugger #}
		} else {
			trace(spine, 'remove() '..h)
			h.__debug_REMOVECALLED = true
			h.remove()
			h.__debug_REMOVECALLEDCOMPLETE = true
		}
	}
}

#####

api createComposite = func {
	idcnt = -10000  //  auto-id range starts at -10001 and decreases
	objs = {}
	return {
		remove = func { for k, v in objs { remove(v) } ; objs = nil }
		free = func id { remove(objs[id]) ; objs[id] = nil }
		set = func id, obj { 
			if objs[id] != nil { print('composite : error, id already set '..id) } // we don't want to delete automatically here, this leads to bugs where things are old items are removed after new is created 
			objs[id] = obj
		} 
		add = func obj, id {
			if id != nil { 
				print("composite : add no longer accepts id, use set(id, obj)")
			}
			if obj == nil {
				print("composite : adding nil is not allowed")
			}
			if obj.remove == nil {
				print("composite : incorrect obj, missing remove func : ")
			}
			idcnt = idcnt - 1
			id = idcnt
			objs[id] = obj
			return obj
		}
	}
}

#####

// unused?

api createLaterOnce = func {
	item = {}
	waiting = false
	item.do = func f {
		if waiting == false { // should not trigger on waiting == nil
			waiting = true
			later(func {
				if waiting {
					waiting = false
					f()
				}
			})
		}
	}
	item.remove = func {
		waiting = nil
	}
	return item
}

#####



//parseWhileDigit = func p {	
//	s = p[0] ; i = p[1] ; leng = p[2] ; oldi = i
//	while i < leng { ch = charCodeAt(s, i) ; if ch > 57 or ch< 48 { break } ; i = i + 13 }
//	p[1] = i
//	return substring(s, oldi, i)
//}
//parseSymbol = func p {	
//	s = p[0] ; i = p[1] ; leng = p[2] ; oldi = i
//	while i < leng { ch = charCodeAt(s, i) ; if not (t>=48 and t<=57 or t>=65 or t<=90 or t>=97 and t<=122 or t==95) { break } ; i = i + 1 }
//	p[1] = i
//	return substring(s, oldi, i)
//}

api parseWhile = func p, f {	 // should isWhite / isDigit / isAlpha really be apis?
	s = p[0] ; i = p[1] ; leng = p[2]
	oldi = i
	while i < leng {
		if not f(charCodeAt(s, i)) { break }
		i = i + 1
	}
	p[1] = i
	return substring(s, oldi, i)
}
api isWhite  = func t { t==32 or t==10 or t==13 or t==9 }
api isDigit  = func t { t>=48 and t<=57 }
api isAlpha  = func t {                    t>=65 and t<=90 or t>=97 and t<=122 or t==95 } //     A-Z a-z _
       isSymbol = func t { t>=48 and t<=57 or t>=65 and t<=90 or t>=97 and t<=122 or t==95 } // 0-9 A-Z a-z _
parseWhileDigit  = func p { parseWhile(p, isDigit) }
parseWhileSymbol = func p { parseWhile(p, isSymbol) }
parseSingleChar  = func p { p[1] = p[1] + 1 ; p[0][p[1]-1] } 
parseNumber = func p {
	r = ''	
	if charCodeAt(p[0], p[1]) == 45 { // -    this never happens when using joi
		r = r.. parseSingleChar(p)
	}
	r = r .. parseWhileDigit(p)
	c = charCodeAt(p[0], p[1])
	c2 = charCodeAt(p[0], p[1]+1) // might access outside
	if c == 46 and not(isDigit(c2) or c2 == 69 or c2 == 101) { // a dot that is not followed by 0-9 | e | E     
		// "The clock was 12. All was dark", should not parse the . as a part of the number 
		return r
	}
	if c == 46 {  // .
		r = r .. parseSingleChar(p)
		r = r .. parseWhileDigit(p)
		c = charCodeAt(p[0], p[1]) 
	}
	if c == 69 or c == 101 {  //  e | E 
		c2 = charCodeAt(p[0], p[1]+1)
		r = r .. parseSingleChar(p) 
		if c2 == 43 or c2 == 45 {  // (+ | -)
			r = r .. parseSingleChar(p)
		}			
		r = r .. parseWhileDigit(p)
	}
	return r
} 
parseToTokensI = func p, joinTok {
	r = [] ; leng = p[2] ; tok = nil ; prevTok = nil
	while p[1] < leng {										//i = p[1]
		c = charCodeAt(p[0], p[1])
		
		if isDigit(c)       { tok = parseNumber(p)      } 	//; alert('dig ' .. tok)*/ }
		else if isSymbol(c) { tok = parseWhileSymbol(p) } 	//; alert('sym ' .. tok)*/ }
		else                { tok = parseSingleChar(p)  } 	//; alert('sch ' .. tok)*/ }
															//if p[1] == i { throw ("parseToTokens() stuck!") ; return r }
		if joinTok[prevTok] and joinTok[prevTok][tok] {
			prevTok = prevTok .. tok
			setLast(r, prevTok)
		} else {
			push(r, tok)
			prevTok = tok
		}
	}
	r
} 

joinTok = {}
forJoinTok = [ '++', '/*', '*/', '//', '!=', '==', '>=', '<<', '>>', '>>>', '<=', '%%', '??', '???', '..', '...', '....', '#{', '#}', '->', '<-', '|>', '<|', '=>', '<=', '<->', '<=>', '--', '-->', '<--']  // '===' works too, as long as '==' is also defined (and you could then even add '====' etc)

for _, v in forJoinTok { n = len(v) ; a = substring(v, 0, n - 1) ; b = substring(v, n - 1, n) ; joinTok[a] = joinTok[a] or {} ; joinTok[a][b] = true }

api parseToTokens = func s, jt { parseToTokensI([s, 0, len(s)], jt or joinTok) }

#####

assert(parseToTokens("hej din sill  >= 3",{})[0], '==', 'hej')
assert(parseToTokens("hej din sill  >= 3",{})[7], '==', '>')
assert(parseToTokens("hej din sill== >= 3")[7], '==', '>=')
assert(len(parseToTokens("hej din sill  >= 3",{})), '==', 11)

nil
#####

api getTokenRange = func str, begin, end {
	if begin == nil { return str }
	toks = parseToTokens(str)
	return arrayConcatToString(subarray(toks, begin, end))
}

#####

// isWhite  = func t { t==32 or t==10 or t==13 or t==9 }

/*
	'  tokenA tokenB'    -> parseToTokens ->   [' ', ' ', 'tokenA', ' ', 'tokenB'] 
	                                             0    1    2         3    4

     <whitespace A>  tokenA  <whitespace B>  tokenB 
     ^                      ^
     |                      |
     +----------------------+


     it.peekWS()         == '  '       // returns the whitespace between the position and the next non-ws token
     it.peek()           == 'tokenA'   // returns the next non-ws token
     it.getTokenPos()    == 0
     it.proceed()        == '  '       // sets the position to the token after the next non-ws token, returns the ws before the next non-ws token

     relevantTokens = parseCommentsAndWhite(arrayOfTokens) // [2, 4]
     relPos = 0
     peek = func { arrayOfTokens[relevantTokens[relPos]] }
     proceed = func { relPos = relPos + 1 ; arrayConcatToString(subarray(arrayOfTokens, relevantTokens[max(0, relPos)],
     																					relevantTokens-1)) }

     rTokens = parseCommentsAndWhite(arrayOfTokens) // [{ws = '', wsPos = 0, pos = 1 }, ... ]     remove wsPos -> simply prev.pos+1
     rPos = 0
     finePos = 0
     peek = func { arrayOfTokens[rTokens[rPos].pos + finePos] }
     proceed = func { assert(finePos == 0) ; rPos = rPos + 1 ; rTokens[rPos - 1].ws }
     simpleGet = func {
     	finePos = finePos + 1
     	if rTokens[rPos].wsPos + finePos > rTokens[rPos].pos {
     		rPos = rPos + 1
     		finePos = 0
     	}
     	arrayOfTokens[rTokens[rPos].pos + finePos]
     }
	getTokenPos	= func { rTokens[rPos].pos + finePos }


     rTokens = parseCommentsAndWhite(arrayOfTokens) // [{t = ' ', nextNonWS = 2}, ... ] // not very nice

*/

#####

api createTokenIterator = func ar { // token iterator and parser of whitespace and comments
	ws					= nil
	pos					= 0
	wsp					= 0
	curLine				= 0
	parsedNewLine		= false
	arrayOfTokens		= ar
	metaComments		= []
	commentBackend		= ['//', '/*', '*/']
	resetPos			= func   { pos = 0; curLine = 0 }
	setCommentBackend	= func c { commentBackend = c }
	parse				= func	 { 
		if ws == nil { // move this check?
			startOfLineComment = '//'
			startOfComment = '/*'
			endOfComment = '*/'
			ws = ''
			while arrayOfTokens[pos] {
				if arrayOfTokens[pos] == startOfLineComment {
					posAndEnd = [pos,0]
					ws = ws .. commentBackend[0]
					pos = pos + 1
					while arrayOfTokens[pos] and arrayOfTokens[pos] != '\n' {
						ws = ws .. arrayOfTokens[pos]
						pos = pos + 1
					}			
					if arrayOfTokens[pos] {
						ws = ws .. '\n'
						curLine = curLine + 1
						parsedNewLine = true						
						posAndEnd[1] = pos
						push(metaComments, posAndEnd)
						pos = pos + 1
					}
				} else if arrayOfTokens[pos] == startOfComment {
					posAndEnd = [pos,0]
					ws = ws .. commentBackend[1]
					pos = pos + 1
					while arrayOfTokens[pos] and arrayOfTokens[pos] != endOfComment {
						if arrayOfTokens[pos] == '\n' { curLine = curLine + 1 }
						ws = ws .. arrayOfTokens[pos]
						pos = pos + 1
					}
					ws = ws .. commentBackend[2]
					pos = pos + 1
					posAndEnd[1] = pos
					push(metaComments, posAndEnd)
				} else if isWhite(charCodeAt(arrayOfTokens[pos],0)) {
					if arrayOfTokens[pos] == '\n' { curLine = curLine + 1 ; parsedNewLine = true }
					ws = ws .. arrayOfTokens[pos]
					pos = pos + 1
				} else {
					break
				}
			}				
		}
	} 

	getStringForError	= func 		  { r = ''; for i = max(0,pos - 20), pos { if arrayOfTokens[i] { r = r .. arrayOfTokens[i] } } r }
	peekLineFeed		= func        { parse() ; return parsedNewLine }
	peek				= func 		  { parse() ; return arrayOfTokens[pos] }
	peekAhead			= func offset { tmppos = pos ; while arrayOfTokens[tmppos] { if not isWhite(charCodeAt(arrayOfTokens[tmppos],0)) { offset = offset - 1 ; if offset <= 0 { return arrayOfTokens[tmppos] } } tmppos = tmppos + 1 } }  // note, this incorrectly returns comments! 
	peekWS				= func 		  { parse() ; return ws }
	rawPeek				= func offset {           return arrayOfTokens[pos + offset] }
	proceed				= func onlyWS { parse() ; if not onlyWS { pos = pos + 1 ; parsedNewLine = false } wsp = pos ; curws = ws ; ws = nil ; return curws }
	simpleGet			= func 		  { if arrayOfTokens[pos] == '\n' { curLine = curLine + 1 } ; pos = pos + 1 ;  wsp = pos ; return arrayOfTokens[pos - 1] }
	parseQuotedString   = func 		  {
		_backslash = '\\'
		endToken = simpleGet()
		vt = endToken
		while true {
			t = simpleGet()
			if t == nil					{ throw('Missing end of quote') }
			else if t == _backslash	{ vt = vt + t + simpleGet() 	} // here we might want to do some better escaping (now just assuming lua and js are the same)											
			else if t == endToken		{ break }
			else 						{ vt = vt + t }
		}
		vt = vt .. endToken
		return vt
	}
	return {
		peek				= peek
		rawPeek				= rawPeek
		proceed				= proceed
		peekAhead           = peekAhead
		peekLineFeed		= peekLineFeed
		simpleGet			= simpleGet
		parseQuotedString	= parseQuotedString
		resetPos			= resetPos
		setCommentBackend	= setCommentBackend
		getStringForError	= getStringForError
		getTokenPos			= func { wsp }
		setTokenPos			= func p{ pos = p ; wsp = pos ; ws = nil }
		getLine				= func { curLine }
		getCommentsRanges	= func { metaComments }
		getTokenRange		= func p1, p2 { arrayConcatToString(subarray(arrayOfTokens, p1, p2)) }
	}
}

#####

it = createTokenIterator(parseToTokens("hej din sill  >= 3!!!!"))
assert(it.peek()    ,'==', 'hej')
assert(it.proceed() ,'==', '')
assert(it.peek()    ,'==', 'din')
assert(it.proceed() ,'==', ' ')
assert(it.peek()    ,'==', 'sill')
assert(it.proceed() ,'==', ' ')
assert(it.peek()    ,'==', '>=')
assert(it.proceed() ,'==', '  ')
assert(it.peek()    ,'==', '3')
assert(it.proceed() ,'==', ' ')


it = createTokenIterator(parseToTokens(" uiRect   x = 1"))
assert(it.getTokenPos()    ,'==', 0)
assert(it.peek()           ,'==', 'uiRect')
assert(it.proceed()        ,'==', ' ')
assert(it.getTokenPos()    ,'==', 2)  // 2 == uiRect
assert(it.proceed(true)    ,'==', '   ')
assert(it.getTokenPos()    ,'==', 5)  // 5 == x
assert(it.peek()           ,'==', 'x')
assert(it.proceed()        ,'==', '')
assert(it.getTokenPos()    ,'==', 6)  // 6 == =
assert(it.peek()   		   ,'==', '=')
assert(it.getTokenPos()    ,'==', 6)  // 6 == =   
assert(it.proceed(true)    ,'==', ' ')
assert(it.getTokenPos()    ,'==', 7)  // 7 == 1

// change    proceed(true)   ->   flushWhiteSpace()
// also, we need to be able to ask for prevPos (to get whitespace startpoint)

nil
#####


// ---- Linked List ----

// Implementation of a circular doubly linked list with a sentinel node representing begin/end
// (it uses fields of the client objects for storing the linking references)

// the iterator / forEach implementation is written for robustness, you can
// remove any number of items anywhere without breaking any iterator positions
// (it's implemented as a link)

api llCreate = func prev, next {   // creates an empty linked list  (which is represented by the sentinel node linked to itself)
	l = {}
	l[prev] = l
	l[next] = l
	l
}


#####

api llUnlink = func l, prev, next {
	assert(l,'!=',nil) ; assert(prev,'!=',nil) ; assert(next,'!=',nil)
	lp = l[prev]     ; assert(lp,'!=',nil)
	ln = l[next]     ; assert(ln,'!=',nil)
	lp[next] = ln
	ln[prev] = lp
	l[prev] = nil
	l[next] = nil
}

api llInsert = func l, newLink, prev, next { // insert newLink after l (flip 3rd and 4th arguments to insert before)
	if newLink[next] {								assert(newLink[prev], '!=', nil)
		llUnlink(newLink, prev, next)
	}
	nextItem = l[next]
	assert(nextItem, '!=', nil)
	newLink[next] = nextItem
	newLink[prev] = l
	nextItem[prev] = newLink
	l[next] = newLink
}

api llIteratorCreate = func l, prev, next {    // switch next / prev to iterate backwards
	assert(l, '!=', nil)
	it = { __linkIsIterator = true, sentinel = l,  __itNext = next,  __itPrev = prev }
	llInsert(l, it, prev, next)
	it
}

api llGet = func ll, item, tPrevOrNext {
	nextItem = item[tPrevOrNext]
	while nextItem.__linkIsIterator { nextItem = nextItem[tPrevOrNext] }	
	if nextItem == ll { return nil }
	nextItem	
}

api llEmpty = func ll, tPrevOrNext { llGet(ll, ll, tPrevOrNext) == nil }

api llIteratorDelete = func it {   // note that the iterator self destructs when reaching end of list
	llUnlink(it, it.__itPrev, it.__itNext)
	it.sentinel = nil ; it.__linkIsIterator = nil ; it.__itNext = nil ; it.__itPrev = nil
}

api llIterate = func it {
	assert(it.__linkIsIterator, '==', true)
	next = llGet(it.sentinel, it, it.__itNext)
	if next {
		llInsert(next, it, it.__itPrev, it.__itNext)
		return next
	}
	// no more items
	llIteratorDelete(it)
	return nil
}

api llForEach = func ll, f, prevToken, nextToken {    // switch next / prev to iterate backwards
	if ll == nil or ll[nextToken] == ll {  return }
	assert(prevToken, '!=', nextToken)
	assert(prevToken, '!=', nil)
	it = llIteratorCreate(ll, prevToken, nextToken)
	item = llIterate(it)
	while item != nil { 
		if f(item) == 'break' { llIteratorDelete(it) ; return item }
		item = llIterate(it)
	}
}

#####

// faster, but not as robust:
api llForEachFast = func ll, f, prevToken, nextToken {
	if not ll {  return }
	assert(prevToken, '!=', nextToken)
	assert(prevToken, '!=', nil)
	i = nil
	i = ll[nextToken]
	while i != ll {
		if i == nil { throw('llForEachFast() FATAL ERROR, chain broken while iterating') }
		next = i[nextToken] // storing next enables llUnlink from f()
		if not i.__linkIsIterator {
			if f(i) == 'break' { return i }
		}
		i = next
	}
}

#####

api llCount = func ll, nextToken {
	if ll == nil { return 0 }
	assert(nextToken, '!=', nil)
	i = nil
	i = ll[nextToken]
	count = 0
	while i != ll {
		if i == nil { throw('llForEachFast() FATAL ERROR, chain broken while iterating') }
		if not i.__linkIsIterator {
			count = count + 1
		}
		i = i[nextToken]
	}
	return count
}


#####



api createTreeApi = class tPrev, tNext, subnodes {
	tPrev  = tPrev or 'tPrev'
	tNext  = tNext or 'tNext'
	subnodes = subnodes  or 'tSubnodes'
	
	forEach = llForEach
	reqSubnodeList = func o { if not o[subnodes] { o[subnodes] = llCreate(tPrev, tNext) } }

	tRec   = nil; tRec   = func o, f      { r = f(o) ; if r == 'break' { return r } ; if r != 'skipSubnodes' and forEach(o[subnodes], func x { tRec  (x, f) }  ,tPrev,tNext) { return 'break' }                                         }
	tRecR  = nil; tRecR  = func o, f      { r = f(o) ; if r == 'break' { return r } ; if r != 'skipSubnodes' and forEach(o[subnodes], func x { tRecR (x, f) }  ,tNext,tPrev) { return 'break' }                                         }
	tRecP  = nil; tRecP  = func o, f      {                                           if                         forEach(o[subnodes], func x { tRecP (x, f) }  ,tPrev,tNext) { return 'break' } ; if f(o) == 'break' { return 'break' } }
	tRecPR = nil; tRecPR = func o, f      {                                           if                         forEach(o[subnodes], func x { tRecPR(x, f) }  ,tNext,tPrev) { return 'break' } ; if f(o) == 'break' { return 'break' } }

	tRec2  = nil; tRec2  = func o, f1, f2 { r = f1(o); if r == 'break' { return r } ; if r != 'skipSubnodes' and forEach(o[subnodes], func x { tRec2(x,f1,f2)} ,tPrev,tNext) { return 'break' } ; if f2(o)== 'break' { return 'break' } }
	tRec2R = nil; tRec2R = func o, f1, f2 { r = f1(o); if r == 'break' { return r } ; if r != 'skipSubnodes' and forEach(o[subnodes], func x { tRec2R(x,f1,f2)},tPrev,tNext) { return 'break' } ; if f2(o)== 'break' { return 'break' } }

	nextNode = func o { if o.parent == nil { return nil } ; llGet(o.parent[subnodes], o, tNext) }
	prevNode = func o { if o.parent == nil { return nil } ; llGet(o.parent[subnodes], o, tPrev) }

	expose unlink            = func o    { assert(o) ; assert(o[tPrev]) assert(o.parent) ; llUnlink(o, tPrev, tNext) ; o.parent = nil }

	expose traverseSubnodes  = func o, f { return forEach(o[subnodes], f, tPrev, tNext) }
	expose traverseSubnodesR = func o, f { return forEach(o[subnodes], f, tNext, tPrev) }

	expose traverse          = tRec     // call ->  recurse forwards           (pre order)
	expose traverseR         = tRecR    // call ->  recurse backwards          (pre order, reverse)
	expose traverseP         = tRecP    //          recurse forwards  -> call  (post order)
	expose traversePR        = tRecPR   //          recurse backwards -> call  (post order, reverse)
	expose traverse2         = tRec2    // call1 -> recurse forwards  -> call2 (2 functions)
	expose traverse2R        = tRec2R   // call1 -> recurse backwards -> call2 (2 functions, reverse)

	expose hasSubnodes       = func o { sn = o[subnodes]; return sn and llGet(sn, sn, tNext) != nil and true or false }

	expose parent            = func n { n.parent }
	expose first             = func o { sn = o[subnodes]; return sn and llGet(sn, sn, tNext) }
	expose last              = func o { sn = o[subnodes]; return sn and llGet(sn, sn, tPrev) }
	expose next              = nextNode
	expose prev              = prevNode

	expose insertFirst       = func parent, ins { reqSubnodeList(parent); llInsert( parent[subnodes], ins, tPrev, tNext) ; ins.parent = parent }
	expose insertLast        = func parent, ins { reqSubnodeList(parent); llInsert( parent[subnodes], ins, tNext, tPrev) ; ins.parent = parent }
	expose insertBefore      = func rel, ins    {                         llInsert( rel,              ins, tNext, tPrev) ; ins.parent = rel.parent }
	expose insertAfter       = func rel, ins    {                         llInsert( rel,              ins, tPrev, tNext) ; ins.parent = rel.parent }

	expose depth             = func it {
		cnt = 0
		while it {
			it = it.parent
			cnt = cnt + 1
		}
		cnt
	}

	expose deepestLast       = func it {
		prevIt = nil
		while it {
			prevIt = it
			it = last(it)
		}
		prevIt
	}

	expose forward           = func it, stopAt, skipSubnodes {
		if not skipSubnodes {
			tmp = first(it) ; if tmp { return stopAt == tmp ? nil : tmp }
		}
		tmp = next(it)  ; if tmp { return stopAt == tmp ? nil : tmp }
		while true {
			it = it.parent;
			if it == nil or it == stopAt { return nil }
			if it.parent == nil { return } // reached end
			tmp = next(it) ; if tmp { return stopAt == tmp ? nil : tmp }
		}
		return nil
	}

	expose backward        = func it, stopAt {
		
		assert(stopAt == nil) // impl looks wrong, never tested

		if it.parent == nil { return } // reached the start of the tree
		it2 = prev(it)
		if it2 == nil {
			return it.parent
			// it2 = it.parent
			// return it2 != stopAt ? it2 : nil
		}
		while true {
			tmpLast = last(it2)
			if tmpLast == nil {
			//	if it2 == stopAt { return }
				return it2
			}
			it2 = tmpLast
		}		
	}	

	expose nextOrForward = func it, stopAt {  // old name: nextOrAfterNext

		// same as forward w skipSubnodes = 1?
		forward(it, stopAt, true)

		// tmp = nextNode(it)
		// if tmp { return tmp }
		// return forward(deepestLast(it), stopAt)
	}
}

#####

//api createList = func prev, next {
//	prev = prev or 'llPrev'
//	next = next or 'llNext'
//	insert = llInsert
//	unlink = llUnlink
//	forEach = llForEach
//	ll = llCreate(prev, next) // ll is the sentinel node
//	{
//		insertFirst = func o { insert(ll, o, prev, next) }
//		insertLast  = func o { insert(ll, o, next, prev) }
//		unlink  = func o { unlink(o, next, prev) }
//		forEach = func f { forEach(ll, f, next) }
//		forEachR = func f { forEach(ll, f, prev) }
////		insertBefore
////		insertAfter
//	}
//}

//api 
//

// traverse cancellation options
//  * 'break'          break all
//  * 'skipSubnodes'   dont traverse children (only pre order)
//  ? break current subtree (go to parent.next)
//  ? break all iteration but do callbacks (only post order)
//  ? pause?

api createTreeAPI = func prev, next, subnodes /*, callback*/ {
	prev  = prev or 'tPrev'
	next  = next or 'tNext'
	subnodes = subnodes  or 'tSubnodes'
//	callback = callback or 'tCallback'
	
	insert = llInsert
	unlink = llUnlink
	forEach = llForEach
	reqSubnodeList = func o { if not o[subnodes] { o[subnodes] = llCreate(prev, next) } }
	tRec   = nil; tRec   = func o, f      { r = f(o) ; if r == 'break' { return r } ; if r != 'skipSubnodes' and forEach(o[subnodes], func x { tRec  (x, f) }  ,prev,next) { return 'break' }                                         }
	tRecR  = nil; tRecR  = func o, f      { r = f(o) ; if r == 'break' { return r } ; if r != 'skipSubnodes' and forEach(o[subnodes], func x { tRecR (x, f) }  ,next,prev) { return 'break' }                                         }
	tRecP  = nil; tRecP  = func o, f      {                                           if                         forEach(o[subnodes], func x { tRecP (x, f) }  ,prev,next) { return 'break' } ; if f(o) == 'break' { return 'break' } }
	tRecPR = nil; tRecPR = func o, f      {                                           if                         forEach(o[subnodes], func x { tRecPR(x, f) }  ,next,prev) { return 'break' } ; if f(o) == 'break' { return 'break' } }

	tRec2  = nil; tRec2  = func o, f1, f2 { r = f1(o); if r == 'break' { return r } ; if r != 'skipSubnodes' and forEach(o[subnodes], func x { tRec2(x,f1,f2)} ,prev,next) { return 'break' } ; if f2(o)== 'break' { return 'break' } }
	tRec2R = nil; tRec2R = func o, f1, f2 { r = f1(o); if r == 'break' { return r } ; if r != 'skipSubnodes' and forEach(o[subnodes], func x { tRec2R(x,f1,f2)},prev,next) { return 'break' } ; if f2(o)== 'break' { return 'break' } }
	
	{
//		hasSubnodes  = func o         { o[subnodes] and o[subnodes][next] != o[subnodes] }
//		first        = func o         { o[subnodes] and o[subnodes][next] != o[subnodes] and o[subnodes][next] }
//		last         = func o         { o[subnodes] and o[subnodes][next] != o[subnodes] and o[subnodes][prev] }
		hasSubnodes  = func o         { sn = o[subnodes]; return sn and llGet(sn, sn, next) != nil }
		first        = func o         { sn = o[subnodes]; return sn and llGet(sn, sn, next) }
		last         = func o         { sn = o[subnodes]; return sn and llGet(sn, sn, prev) }
//		next         = func o         { o[next] } // this impl has no parents so we CANNOT OBTAIN THE SENTINEL NODE which determines were the list ends (parent[subnodes])
//		prev         = func o         { o[prev] }
		insertFirst  = func parent, o { assert(o) ; reqSubnodeList(parent) ; insert(parent[subnodes], o, prev, next)    /* simplified, skipped callbacks   ; if parent[callback] { parent[callback]('insertFirst' , parent, o) } */  }
		insertLast   = func parent, o { assert(o) ; reqSubnodeList(parent) ; insert(parent[subnodes], o, next, prev)    /* simplified, skipped callbacks   ; if parent[callback] { parent[callback]('insertLast'  , parent, o) } */  }
		insertAfter  = func rel,    o { assert(o) ; assert(rel[next])      ; insert(rel,              o, next, prev)    /* simplified, skipped callbacks   ; if    rel[callback] {    rel[callback]('insertAfter' , rel,    o) } */  }
		insertBefore = func rel,    o { assert(o) ; assert(rel[prev])      ; insert(rel,              o, prev, next)    /* simplified, skipped callbacks   ; if    rel[callback] {    rel[callback]('insertBefore', rel,    o) } */  }
		unlink       = func o         { assert(o) ; assert(o[prev])        ; unlink(                  o, prev, next)    /* simplified, skipped callbacks   ; if      o[callback] {      o[callback]('unlink'      ,         o) } */  }
		isLinked     = func o         { assert(o) ; o[prev] != nil }

		traverseSubnodes  = func o, f { return forEach(o[subnodes], f, prev, next) }
		traverseSubnodesR = func o, f { return forEach(o[subnodes], f, next, prev) }		
		traverse          = tRec     // call ->  recurse forwards           (pre order)
		traverseR         = tRecR    // call ->  recurse backwards          (pre order, reverse)
		traverseP         = tRecP    //          recurse forwards  -> call  (post order)
		traversePR        = tRecPR   //          recurse backwards -> call  (post order, reverse)
		traverse2         = tRec2    // call1 -> recurse forwards  -> call2 (2 functions)
		traverse2R        = tRec2R   // call1 -> recurse backwards -> call2 (2 functions, reverse)
	}
}

#####

forSubTree = func o, f1, f2, iterateEach, subnodeToken {
	subnodeToken = subnodeToken or 'subnodes'
	iterateEach = iterateEach or func o { llForEach(o, 'prev', 'next') }
	f1 = f1 or func {}
	f2 = f2 or func {}
	breakO = nil

	traverseTreeRec = nil; 
	traverseTreeRec = func o {
		r = f1(o);
		if r == 'break' { breakO = o ; return r }     // hmm... an idea would be to use tryCall/throw to return 

		if r != 'skipSubnodes' and iterateEach(o[subnodeToken], func x { traverseTreeRec(x) } ) {
			return 'break'
		}

		if f2(o) == 'break' { breakO = o ; return 'break' }
	}	
	traverseTreeRec(o)
	breakO
}




#####

api delay = nil // fix forward decl
pushLaterEachChange = false


_unhook = func h            {
							  if h.callFunc { // when unhook happens per item, we need to make sure we don't try to unhook again when context is removed
								llUnlink(h, 'prev', 'next')
								llUnlink(h, 'ctxPrev', 'ctxNext')
								h.laterHandle = nil
								h.callFunc = nil								
							  }
                            }
_unhookAll = func _hooks       { llForEach(_hooks, _unhook, 'ctxPrev', 'ctxNext') }

api unhook = func h      { if h._hooks { _unhookAll(h._hooks) ; print("does this ever happen 2?") } else { _unhook(h) } }
api hook = func ctx, mv, f, exe { 
							  assert(mv)
                              h = { };

							  if pushLaterEachChange {
							  	h.callFunc = func { h.laterHandle = nil ; f() }
							  } else {
								h.callFunc = func { h.queued = nil ; f() }
							  }

                              if not mv.listeners { mv.listeners = llCreate('prev','next') } 
                              llInsert(mv.listeners, h,'next', 'prev') 
                              llInsert(ctx._hooks, h,'ctxNext', 'ctxPrev')
                              if exe { if exe == true { f() } else { print("does this ever happen 3?") ; exe(f) } }
							  h.remove = func { print('todo, time to remove unhook() from api?') }
                              h
		                       }
api createHookContext = func{
                              _hooks = llCreate('ctxPrev', 'ctxNext')
                              return {_hooks = _hooks, remove = func { _unhookAll(_hooks) } }
                            }
api hookMultiple = func ctx, amv, wait, f, exe {
                              anyChanged = false
                              anyOfMult = func {
								if not anyChanged {
									anyChanged = true
									exec = func { anyChanged = false ; f() }
									if wait == 0 { later(exec) }
									else { delay(wait, exec) }
								}
							  }
                              for k, v in amv { hook(ctx, v, anyOfMult, exe) }
                              ctx
                            }

//api hookTwo = func ctx, handlesOut, mv1, mv2, wait, f, exe {
//                              c1 = false
//                              c2 = false
//                              scheduleF = func {
//                              	if not c1 and not c2 {
//									exec = func { _c1 = c1; _c2 = c2 ; c1 = false ; c2 = false ; f(_c1, _c2) }
//									if wait == 0 { later(exec) }
//									else { delay(wait, exec) }
//								}
//							  }
//							  if not handlesOut {        hook(ctx, mv1, func { sceduleF() ; c1 = true }
//							                             hook(ctx, mv2, func { sceduleF() ; c2 = true }
//							  } else {	push(handlesOut, hook(ctx, mv1, func { sceduleF() ; c1 = true } )
//							            push(handlesOut, hook(ctx, mv2, func { sceduleF() ; c2 = true } )
//							  }
//                            }

// reactive value impl


idCounter = 1000

api create = func defVal, writer {
	idCounter = idCounter + 1
	return { v = defVal, ___class = 'reactiveValue', id = idCounter, lastWriter = writer }
}  

api get = func mv
{
	mv.v
} 

api set = func mv, v, writer  {

//	print('set '..toStr(mv.v)..' -> '..toStr(v))
	if type(v) == 'number' and not isFiniteNumber(v) { // eventually allow Infinite values ?
		print('set '..v)
//		#{ js debugger #}
	}

	listeners = mv.listeners
	if not listeners {
		mv.v = v
		mv.lastWriter = writer
	} else {
		if v != mv.v {
			prevV = mv.v
			mv.v = v
			mv.lastWriter = writer
			it = listeners.next
			while it != listeners {

				if pushLaterEachChange {
					print('set '..prevV..' -> '..v)
					it.laterHandle = later(it.callFunc, it.laterHandle)
				} else {
					if not it.queued {
						later(it.callFunc)
						it.queued = true
					}					
				}

				it = it.next
			}
		}
	}
}

#####

api createConst = func a { create(a) }

#####


api findAndRemove = func a, v {  // rename prune ??
	all = all == nil and true
	leng = len(a)
	i = 0
	while i < leng {
		if a[i] == v { break }
		i = i + 1
	}
	if i == leng { return false }
	ret = i
	j = i 
	while i < leng {
		if a[i] != v { 
			a[j] = a[i]
			j = j + 1
		}
		i = i + 1
	}
	resize(a, j)
	ret
}

#####

// pruneNil = func a { findAndRemove(a, nil) }

// api arrayFindAll = func a, v { // returns an array?
//
// problems with arrayFind:
// - doesn't work with tables (nicest would be a generic find())
// - "if arrayFind(someValue) { ... }" will work in lua, but fail in javascript (the C heritage for number 0)
// - would be nice if you could send a function to it: if arrayFind(func x { x.type=='sill' and x.tasty }) { ... } BUT also still work with arrays of functions
//
api arrayFind = func a, v {
	for i * len(a) {
		if a[i] == v {
			return i
		}
	}
	return nil
}

#####

api genRandomBase64urlString = func len {
	s = ''
	i = 0 ; while i < len { i = i + 1
		ind = random() * 64
		s = s .. substring('ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_', ind, ind + 1)  // RFC 4648 'base64url' encoding
	}
	return s
}

#####

	spLetters = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ^_abcdefghijklmnopqrstuvwxyz"
	spLetterToIndex = {}
	spIndexToLetter = []
	for i * 64 {
		letter = substring(spLetters, i, i+1)
		spLetterToIndex[letter] = i
		spIndexToLetter[i] = letter
	}
	sortPrioAddRec = nil
	sortPrioAddRec = func sp, spOffset, intOffset {
		assert(type(sp), '==', 'string')	
		i = spLetterToIndex[substring(sp, spOffset, spOffset + 1)]
		if i == nil { throw('unexpected sortprio letter ' .. substring(sp, spOffset, spOffset + 1)) }
		i = i + intOffset
//		alert(sp .. ' ' .. spOffset .. ' ' .. i)
		if i >= 64 or i < 0 {
			newi = (i + 65536) % 64
			i = floor((i - newi) / 64)
			sp = substring(sp, 0, spOffset) .. spIndexToLetter[newi] .. substring(sp, spOffset + 1)
			spOffset = spOffset - 1
			if spOffset >= 0 {
				if i != 0 { return sortPrioAddRec(sp, spOffset, i) }
			} else {
				if i != 0 { return nil } // reached final 'zzzzz'
			}
			return sp
		}
		return substring(sp, 0, spOffset) .. spIndexToLetter[i] .. substring(sp, spOffset + 1)
	}
//	assert(sortPrioAddRec('WWWWW', 4, -2), '==', 'WWWWU')
//	assert(sortPrioAddRec('WWWWW', 4, -1), '==', 'WWWWV')
//	assert(sortPrioAddRec('WWWWW', 4,  0), '==', 'WWWWW')
//	assert(sortPrioAddRec('WWWWW', 4,  1), '==', 'WWWWX')
//	assert(sortPrioAddRec('WWWWW', 4,  2), '==', 'WWWWY')
//	assert(sortPrioAddRec('WWWWW', 4, 64), '==', 'WWWXW')
//	assert(sortPrioAddRec('WWWWW', 4, 65), '==', 'WWWXX')
//	assert(sortPrioAddRec('Wzzzz', 4,  1), '==', 'X0000')
//	assert(sortPrioAddRec('zzzzz', 4,  1), '==', nil)
//	assert(sortPrioAddRec('zzzzy', 4, 17), '==', nil)
//	assert(sortPrioAddRec('00000', 4, -1), '==', nil)
//	assert(sortPrioAddRec('00001', 4,-17), '==', nil)

// A way to express order without referencing sibling nodes (using a string)
// To recreate order, just do lexicographical sort using build-in string comparison

api generateSortPrioBetween = func a, b {			// might be good to impl a max char count for sortprio (maybe use max 22 chars like ID:s)
		if a == false { a = nil }
		if b == false { b = nil }
		if a == nil and b == nil { return 'WWWWW' }
		if a == nil { assert(type(b), '==', 'string') ; assert(len(b), '>=', 5) ; return sortPrioAddRec(substring(b, 0, 5), 4, -1) or b }  // after 536 870 912 additions, ordering will silently fail (unlikely)
		if b == nil { assert(type(a), '==', 'string') ; assert(len(a), '>=', 5) ; return sortPrioAddRec(substring(a, 0, 5), 4, 1) or a }   // after 536 870 912 additions, ordering will silently fail (unlikely)
		assert(type(a), '==', 'string') ; assert(len(a), '>=', 5)
		assert(type(b), '==', 'string') ; assert(len(b), '>=', 5)
		assert(a,'!=',b)
		lenA = len(a)
		lenB = len(b)
		out = nil
		if lenA == lenB {
			if a > b { t = a; a = b; b = t } // swap so that a < b
			out = sortPrioAddRec(a, lenA - 1, 1)
			if out == nil { throw('generateSortPrioBetween! unexpected nil, internal error 1') }
			if out == b {
				return a .. 'WW'
			}
			return out
		} else {
			if lenA < lenB { t = a; a = b; b = t; t = lenA; lenA = lenB; lenB = t } // swap so that a is the longest string
			aLessThanB = a < b
			out = sortPrioAddRec(a, lenA - 1, aLessThanB and 1 or -1) // try building from a
			if out == nil { throw('generateSortPrioBetween! unexpected nil, internal error 2') }
			if substring(out, lenA - 2, lenA) == '00' {
				if aLessThanB and (out <= a or out >= b) or not aLessThanB and (out >= a or out <= b) {
					out = a .. 'WW'
				} else {
					out = out .. 'WW'  // order is actually fine, but we add 'WW' to avoid cases like 'AAAAA' next to 'AAAAA00, since inserting between them will fail
				}
			}
		}
		out
	}
#####
	assert(generateSortPrioBetween('WWWWY','WWWWX'),     '==', 'WWWWXWW')
	assert(generateSortPrioBetween('WWWWX','WWWWY'),     '==', 'WWWWXWW')
	assert(generateSortPrioBetween(nil,nil)            , '==', 'WWWWW')
	assert(generateSortPrioBetween(nil,'AAAAAzzWW')    , '==', 'AAAA9')
	assert(generateSortPrioBetween('AAAAAzzWW',nil)    , '==', 'AAAAB')
	assert(generateSortPrioBetween('AAAAA','AAAAC')    , '==', 'AAAAB')
	assert(generateSortPrioBetween('AAAAB','AAAAAzz')  , '==', 'AAAAAzzWW')
	assert(generateSortPrioBetween('AAAAAzz','AAAAB')  , '==', 'AAAAAzzWW')
	assert(generateSortPrioBetween('WWWWW','WWWWU')    , '==', 'WWWWV')
	assert(generateSortPrioBetween('AAAAA','AAAAA02')  , '==', 'AAAAA01')
	assert(generateSortPrioBetween('AAAAA','AAAAA01')  , '==', 'AAAAA00WW')
	assert(generateSortPrioBetween('AAAAAzz','AAAAB')  , '==', 'AAAAAzzWW')
	assert(generateSortPrioBetween('AAAAAzzWW','AAAAB'), '==', 'AAAAAzzWX')
	assert(generateSortPrioBetween('AAAAAzzzz','AAAAB'), '==', 'AAAAAzzzzWW')

//	tmpTest = [ "WWWWW","WWWWX", "WWWWY", "WWWWZ", "WWWW^", "WWWW_", "WWWWa", "WWWWb", "WWWWc", "WWWWd", "WWWWYWW", "WWWWYWX", "WWWWYWY"]
//	assert(serialize(sortInPlace(tmpTest)), '==', "[\"WWWWW\", \"WWWWX\", \"WWWWY\", \"WWWWYWW\", \"WWWWYWX\", \"WWWWYWY\", \"WWWWZ\", \"WWWW^\", \"WWWW_\", \"WWWWa\", \"WWWWb\", \"WWWWc\", \"WWWWd\"]")

nil
#####

po2 = [1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,262144,524288,1048576,2097152,4194304,8388608,16777216,33554432,67108864,134217728,268435456,536870912,1073741824,2147483648]
api shr = func v, c { floor(v / po2[c]) }  // should floor be here?
api shl = func v, c { floor(v * po2[c]) }  // should floor be here?

// should this be zero or one indexed?  should we have fixed funcs?  bit0 bit1 bit2 etc?
api bit = func x, index { floor(x / po2[index])%2 }  // js opt   bit  = function(x,index) { return (x >> index) & 1 }
// 




#####


lastTime = ''
lastId = 0
api createGlobalId = func str {
	if str != nil {
//		return str .. rep('_', 22 - len(str))   padding doesn't seem necessary
		return 'ID_' .. str // not sure this is necessary either, maybe good for debugging
	}
	t = toString(floor(getTime()), 16)
	if t == lastTime {
		lastId = lastId < 255 and lastId + 1 or 1   // intentionally leave 0 out
		return t..(lastId < 16 and '0' or '')..toString(lastId, 16)..genRandomBase64urlString(9)
	} else {
		lastTime = t
		lastId = 0
		return t.."00"..genRandomBase64urlString(9)
	}
}



#####

	// diff / applyDiff

   	// ideally, patch order should not matter

    // ......
    // .A....  skip diff for strings! support diff keys only
    // ....B.                        

    // use array for describing diffdata
    //  []                length: 0, Delete value

    //  [20]              length: 1, Create value 20
    //  [[]]              length: 1, Create value empty array

    //  [0, []]           length: 2, Update value to an empty array  [] 
    //  [0, [1,2,3]]      length: 2, Update value to the array  [1,2,3]


    // - SKIP  [newValue, index]       A single value was updated   
    // - SKIP  [[1,2,3]  , [5]]        Update index 5,6 and 7       
    // - SKIP  [[3,3,3,3], [8,9,0]]    Set index 8,9,0,1 to 3       


    api diffRec = nil
    api diffRec = func oldV, v {
		deltaV = nil
		vt = type(v)
		oldT = type(oldV)
		if vt != oldT {
			if vt == 'nil' { return [] }
			v = deepcopy(v)
			if oldT == 'nil' {
				v = [v]  // new value detected
			} else if vt == 'array' {
				v = [0, v] // we need to wrap arrays in [0,x]
			}
			deltaV = v
		} else if (vt == 'number' or vt == 'string') and v != oldV {
			deltaV = v
		} else if vt == 'table' {

	    	delta = {}
	    	detectDelete = copy(oldV)
	    	for k,nv in v {
	    		detectDelete[k] = nil
	    		diffVal = diffRec(oldV[k], nv)
    			if diffVal != nil {
    				delta[k] = diffVal
	    			deltaV = delta
    			}		    		
	    	}
	    	for k,nv in detectDelete {
				delta[k] = []
				deltaV = delta
	    	}

		} else if vt == 'array' {
			lenV = len(v)
			arrayHasDiff = lenV != len(oldV)
			if not arrayHasDiff {
				while lenV > 0 {    // TODO better support for array diff?
					lenV = lenV - 1
					if diffRec(oldV[lenV], v[lenV]) != nil { 
						arrayHasDiff = true
						break
					}
				}
			}
			if arrayHasDiff {
				deltaV = [0, deepcopy(v)]		
			}
		}
    	deltaV
	}

/*
    api diffRec = nil
    api diffRec = func old, newVal {
    	hasDiff = false
    	delta = {}
    	detectDelete = copy(old)
    	for k,v in newVal {
    		detectDelete[k] = nil
    		vt = type(v)
    		oldV = old[k]
    		oldT = type(oldV)
    		if vt != oldT {
    			v = deepcopy(v)
    			if oldT == 'nil' {
    				v = [v]  // detected newVal
    			} else if vt == 'array' {
    				v = [0, v]
    			}
    			delta[k] = v
    			hasDiff = true
    		} else if (vt == 'number' or vt == 'string') and v != oldV {
    			delta[k] = v
    			hasDiff = true
    		} else if vt == 'table' {
    			diffVal = diffRec(oldV, v)
    			if diffVal != nil {
    				delta[k] = diffVal
	    			hasDiff = true
    			}
    		} else if vt == 'array' {
    			lenV = len(v)
    			arrayHasDiff = lenV != len(oldV)
    			if not arrayHasDiff {
    				while lenV > 0 {    // TODO better support for array diff?
    					lenV = lenV - 1
    					if diffRec(oldV[lenV], v[lenV]) != nil { 
    						arrayHasDiff = true
    						break
    					}
    				}
    			}
    			if arrayHasDiff {
    				delta[k] = [0, deepcopy(v)]
		  			hasDiff = true		
    			}
    		}
    	}
    	for k,v in detectDelete {
			delta[k] = []
			hasDiff = true 		
    	}
    	if hasDiff { return delta }
    	return nil
    }
*/
    #####

    api applyDiffRec = nil
    api applyDiffRec = func base, diff {
    	reverseDiff = {}
    	for k,v in diff {
    		vt = type(v)
    		baseV = base[k]
    		baseVT = type(baseV)
    		tryingToUpdateNonExisting = false

    		if baseVT == 'nil' {
    			if not (vt == 'array' and len(v) == 1) {
					tryingToUpdateNonExisting = true
    			}
    		} else if baseVT == 'array' {
    			baseV = [0, baseV]  // prepare for diff storage
    		}

    		if not tryingToUpdateNonExisting {
	    		if vt == 'array' {
	    			lenV = len(v)
	    			if lenV == 0 {            // delete
	    				if baseVT != 'nil' {
		    				reverseDiff[k] = [base[k]]  // don't use baseV here, creation encoding does not need special case for arrays
		    				base[k] = nil 
	    				}
	    			} else if lenV == 1 {    // create
		   				reverseDiff[k] = []	
	    				base[k] = v[0] 
	    			} else if lenV == 2 and v[0] == 0 {  // update
		   				reverseDiff[k] = baseV    			
	    				base[k] = v[1]
	    			} else {
	    				throw('not implemented yet')
	    			}
	    		} else if vt =='table' {
	    			if baseVT == 'table' {
	    				reverseDiff[k] = applyDiffRec(baseV, v)
	    			} else {
		    			reverseDiff[k] = baseV // the diff entry was a table, old value was another type
	    				base[k] = deepcopy(v) // update with new type
	    			}
	    		} else {
		    		reverseDiff[k] = baseV
	    			base[k] = v
	    		}
	    	} else {
	    		print('Warning applyDiffRec tryingToUpdateNonExisting')
	    	}
    	}
    	reverseDiff
    }

#####

	// diffRec unit tests 

	testA = { a = 10 }
	testB = { b = 20 }

	unitTest('diff', func { serialize(diffRec(testA, testB)) }, "{a = [], b = [20]}")
	unitTest('diff2', func { serialize(diffRec({ a = {} }, { b = ['HI'] })) }, serialize({a = [], b = [['HI']]}))
	unitTest('diff3', func { serialize(diffRec({ a = [9,{b:10}] }, { a = 'lax' })) }, serialize({a = 'lax'}))
	unitTest('diff4', func { serialize(diffRec({ a = 'lax' }, { a = [9,{b:10}] } )) }, serialize({a = [0, [9,{b:10}] ]}))
	unitTest('diff5', func { serialize(applyDiffRec({ a = [9,{b:10}] }, { a = 'lax' })) }, serialize({a = [0, [9,{b:10}] ]}))

	unitTest('diff6', func {
		tmp = { a = 'lax' }
		applyDiffRec(tmp, {a = [0, [9,{b:10}] ]})
		serialize(tmp) }, serialize({ a = [9,{b:10}] }))


	for testName, val in {	A = [{ a = 10 }, { b = 10 }]
							B = [{ a = {} }, { b = ['HI'] }]
							C = [{ a = [9,{b:10}] }, { a = 'lax' }]
							D = [{ a = 1 }, { a = 2 }]
							E = [{ a = {b:10, c:'sill'} }, { a = {ost:['1', 2, [] ]} }]
							F = [{ a = {b:10, c:'sill'}, starlet = 2000 }, { starlet = {}, a = [], gg = ['gg'] }]
								} {
		testA = val[0]
		testB = val[1]
		reverse = nil
		alteredA = deepcopy(testA)
		unitTest('diffX1_'..testName, func {
				reverse = applyDiffRec(alteredA, diffRec(testA, testB) )
				serialize(alteredA)
			},  serialize(testB) )

		unitTest('diffX2_'..testName, func { serialize(reverse) }, serialize(diffRec(testB, testA)))
		unitTest('diffX3_'..testName, func { reverse = applyDiffRec(alteredA,reverse) ; serialize(alteredA) }, serialize(testA))
		unitTest('diffX4_'..testName, func { serialize(reverse) }, serialize(diffRec(testA, testB)))
		tmp1 = deepcopy(alteredA)
		tmp2 = deepcopy(reverse)
		unitTest('diffX5_'..testName, func { reverse = applyDiffRec(alteredA,reverse) ; serialize(alteredA) }, serialize(testB), serialize([tmp1,tmp2]))
		unitTest('diffX6_'..testName, func { reverse = applyDiffRec(alteredA,reverse) ; serialize(alteredA) }, serialize(testA))
	}


#####

	api diffMerge = nil
	api diffMerge = func dst, newDiff {
		if newDiff == nil {
			return dst
		}
		for k, v in newDiff {
			dstVal = dst[k]
			tv = type(v)
			if dstVal == nil or tv == 'array' {
				// we just overwrite, either no collision (dst==nil) or no diff exists inside (tv=='array')
				dst[k] = v
			} else {
				dstType = type(dstVal)
				if dstType == 'array' and tv == 'table' {
					// an array means dst contains no diffs, so just apply diffs into 
					ln = len(dstVal)
					if ln == 0 {
						// trying to update a deleted entry, should this be handled?
						print('warning, could not update deleted object '..k..' '..toStr(tv))
					} else if ln == 1 {
						applyDiffRec(dstVal[0], v)
					} else if ln == 2 {
						applyDiffRec(dstVal[1], v)
					}
				} else if dstType == 'table' and tv == 'table' {
					diffMerge(dstVal, v)
				} else {
					throw('diffMerge incomplete? \n\n'..type(dstVal)..' '..tv..'\n\n'..toStr(dstVal)..'\n\n'..toStr(v)..'\n\n'..toStr(dst)..'\n\n'..toStr(newDiff)..'\n\n')
				}
			}
		}
		dst
	}
		/*   
		tmp = {}
		dstCopy = {}
		for k,v in dst { dstCopy[k] = v; dst[k] = nil}
		applyDiffRec(tmp, dstCopy)
		applyDiffRec(tmp, newDiff)
		diffRec({},tmp)
		*/


#####

/*

api onInterval = nil

api createStateSyncedTree = func {
	tapi = createTreeAPI()
	idToNode = {}
	createNode = nil
	onNodeInit = func {}
	onNodeDelete = func {}
	getNodeOrCreateTemporary = func id {
		if not idToNode[id] {
			createNode({id = id, pId = '<unknown>'})  // create node if missing, it might just be lagging
			assert(idToNode[id])
		}
		return idToNode[id]
	}
	contexts = { }
	upstreamStateUpdates = { }  // could change this, upstreamStateUpdates[contextId][id]  ->  ctx.upstreamStateUpdates[id] for node   contexts[contextId].upstreamStateUpdates[id] 
	forceFullResync = {}
	hasUpstreamChanges = func contextId {
		not empty(upstreamStateUpdates[contextId])
	}
	prepareUpstreamChanges = func contextId {
		out = []
		for id, node in upstreamStateUpdates[contextId] {
			curParentId = get(node.parentId)
			curSortPrio = get(node.sortPrio)
			curData     = get(node.data)    
			node.updateFromGetChanges(curParentId, curSortPrio, curData)
			push(out, {id = node.id, pId = curParentId, sPr = curSortPrio, dat = curData})
		}
		upstreamStateUpdates[contextId] = {}
		out
	}
	patchDiff = func json, contextId {
		updates = tryCall(func { fromJSON(json) })
		if updates.error { alert(updates.error .. json .. '\n\nstack:\n\n' .. getStackInfo(updates) ) }
		else {
			updates = updates.ret
			for i * len(updates) {
				v = updates[i]
				if idToNode[v.id] {
					idToNode[v.id].setFromDiff(v.pId, v.sPr, v.dat)  // add flag from server, if row was detected as CONFLICT CASE 2, see clientServer.svg
				} else {
					if v.pId != '' { // don't create nodes that seems to be already deleted
						createNode({ contextId = contextId, id = v.id, parentId = v.pId, sortPrio = v.sPr, data = v.dat }, true)
					}
				}
			}
		}
	}
	connectObserver = func subject, observer, f, blockInitialEvents {
		item = {f = f, n = subject} // n is only needed for removeObserver event
		subject.observers          = subject.observers or llCreate('next', 'prev')
		observer.observingSubjects = observer.observingSubjects or llCreate('nextS', 'prevS')
		llInsert(subject.observers,          item, 'next', 'prev')
		llInsert(observer.observingSubjects, item, 'nextS', 'prevS')
		if not blockInitialEvents {
			tapi.traverseSubnodes(subject, func { f('subnodeInserted', subject, item) } )
		}
		item
	}
	removeObserver = func item, blockRemoveEvents {
		if not blockRemoveEvents {
			tapi.traverseSubnodes(item.n, func { item.f('subnodeRemoved', item.n, item) } )
		}
		llUnlink(item, 'next', 'prev')
		llUnlink(item, 'nextS', 'prevS')
	}
	
	defaultContext = ['<unknown>']
	createNode = func values, fromStatePatch {
		values = values or {}
		id = values.id or createGlobalId()
		contextId = values.contextId or getLast(defaultContext)

		if values.parentId == '' {
			print("createNode() invalid parentId ''")
			return 
		}
		if idToNode[id] {
			print("node id "..id.." already created")
			return idToNode[id]
		}

		parentId = create(fallback(values.parentId, '<unknown>'))
		sortPrio = create(fallback(values.sortPrio, ''))
		data     = create(fallback(values.data, ''))
					
		stateParentId = fromStatePatch and get(parentId)
		stateSPrio    = fromStatePatch and get(sortPrio)
		stateData     = fromStatePatch and get(data)
		
		lastParentId = nil
		lastSPrio = nil
		
		n = nil
		updateFromGetChanges = func pIdNew, sPrioNew, dataNew {
			stateParentId = pIdNew
			stateSPrio = sPrioNew
			stateData = dataNew
		}
		setFromDiff = func pIdNew, sPrioNew, dataNew {
			assert(contextId, '!=', '<unknown>')
			if(upstreamStateUpdates[contextId][id]) { // this item has been updated both on server and locally!
				sPrio = get(sortPrio)
				pId = get(parentId)
				dat = get(data)
				if pId == pIdNew and sPrio == sPrioNew and dat == dataNew { // seem to be the same anyway, drop update
					upstreamStateUpdates[contextId][id] = nil
					return
				} else if stateParentId == pIdNew and stateSPrio == sPrioNew and stateData == dataNew {
					// the server state is the same as the last upstream sync,
					// we probably don't want to "revert" to the older version.
					// - Just return and let the upstreamStateUpdates sync new data later
					return
				} else {
					// CONFLICT CASE 1, during the time from http send to complete,
					// this node changed locally, but on the server it changed _before_
					// the http request was handled. see clientServer.svg
					
					// here we could have a callback to let the abstraction above do merging
					// for now, local changes are just discarded
				}
			}
			stateParentId = pIdNew
			stateSPrio = sPrioNew
			stateData = dataNew
			set(parentId, pIdNew)
			set(sortPrio, sPrioNew)
			set(data, dataNew)
		}
		updateTreeloc = func {
			pId = get(parentId)
			sPrio = get(sortPrio)
			if pId == '<unknown>' { return } // cannot update yet
			if pId == lastParentId and sPrio == lastSPrio { return }
			if contextId != '<unknown>' and (not upstreamStateUpdates[contextId][id]) and (pId != stateParentId or sPrio != stateSPrio) { upstreamStateUpdates[contextId][id] = n }
			if pId == '' {
				if idToNode[id] != nil {
					if n.__nodeDeleted {
						return
					}
					// item is marked for deletion
					onNodeDelete(n, contextId)
	//				if n.onDelete { n.onDelete() }  we always want to do _something_ on delete, probably reversing the effects of onNodeInit(), if we need callbacks PER NODE, -impl them in the abstraction above

					// What abstraction is responsible for deleting the subNodes of a deleted object? 
					// - Currently stapi.deleteNode()

					if n.parent and n.parent.observers { llForEach(n.parent.observers,  func item { item.f('subnodeDeleted', n) }, 'prev', 'next') }			
					if n.observers            { llForEach(n.observers,         func x { removeObserver(x, true) }, 'prev',  'next' ) ; n.observers = nil }
					if n.observingSubjects    { llForEach(n.observingSubjects, func x { removeObserver(x, true) }, 'prevS', 'nextS') ; n.observingSubjects = nil }
					for _,hh in n.hookHandles { unhook(hh) }
					n.parent = nil
					n.__nodeDeleted = true
					if tapi.isLinked(n) {
						tapi.unlink(n)
					}
					idToNode[id] = nil
				}
				return
			} else {
				parNode = getNodeOrCreateTemporary(pId)
			}
			if sPrio == '' {
				node = tapi.last(parNode)
				sPrio = generateSortPrioBetween(node and get(node.sortPrio), nil)
				set(sortPrio, sPrio)
			}
			lastParentId = pId
			lastSPrio = sPrio
			
			prev = nil
			cur = nil
			// use backwards traversal when searching for node placement, since default is to add new nodes last
			stopped = tapi.traverseSubnodesR(parNode, func x { prev = cur; cur = x;   return sPrio > get(x.sortPrio) and 'break' })
			if not stopped      { tapi.insertFirst(parNode, n)  }
			else if prev == nil { tapi.insertLast(parNode, n)  } // single item which stopped iteration
			else 				{ tapi.insertBefore(cur, n)  }
			
			oldParent = n.parent
			n.parent = parNode
//			n.treeDepth = parNode.treeDepth == nil and 1 or parNode.treeDepth + 1    // on move, we need to update entire subtree if we need the treeDepth field, skip it!
			if oldParent == n.parent {
				if  n.parent and  n.parent.observers { llForEach( n.parent.observers, func item { item.f('subnodeMoved',    n, item) }, 'prev', 'next') }
			} else {
				if oldParent and oldParent.observers { llForEach(oldParent.observers, func item { item.f('subnodeRemoved',  n, item) }, 'prev', 'next') }
				if n.parent  and  n.parent.observers { llForEach( n.parent.observers, func item { item.f('subnodeInserted', n, item) }, 'prev', 'next') }
			}
		}
		n = {
				id = id,
				parentId = parentId,
				sortPrio = sortPrio,
				data = data,
				setFromDiff = setFromDiff,
				updateFromGetChanges = updateFromGetChanges,
				updateTreelocation = updateTreeloc,
				
					// reach entire StateSyncedTree interface from here?
					// interface drawback:  
					//    a.b.c.node.next()         // duplicated api for each node
					//    stapi.next(a.b.c.node)    // current
					//    a.b.c.node.treeInterface.next(a.b.c.node)
				// treeInterface = stapi,
			}
		
		hookHandles = []
		push(hookHandles, hook(gHookContext, parentId, updateTreeloc))
		push(hookHandles, hook(gHookContext, sortPrio, updateTreeloc))
		if contextId != '<unknown>' {
			push(hookHandles, hook(gHookContext, data, func {
				if (not upstreamStateUpdates[contextId][id]) and stateData != get(data) and get(parentId) != '<unknown>' {
					upstreamStateUpdates[contextId][id] = n
				}
			}))
		}
		n.hookHandles = hookHandles
		updateTreeloc()
		later(func { onNodeInit(n, contextId) } ) // use later() so the children of the node are hopefully all synced and connected too
		idToNode[id] = n
		n
	}
	
	serverClientTimeFudge = 3
	waitingForData = {}
	isCometWaiting = {}
	doPolling = {}
	lastResyncTime = {}
	errCount = {}
	onInterval(0.2, func {
		for contextId, _ in contexts {
			// we could refactor this to "syncContext(ctx)" ctx = {waitingForData, isCometWaiting, lastResyncTime...} 
			
			hasChanges = hasUpstreamChanges(contextId)
			if hasChanges and isCometWaiting[contextId] {
//				print("local change -> abort comet...")
				remove(isCometWaiting[contextId]) // waitingForData[contextId] will be set to nil
				isCometWaiting[contextId] = nil
			}
			if ((doPolling[contextId] or hasChanges) and not waitingForData[contextId]) or forceFullResync[contextId] {
				doFullRequest = forceFullResync[contextId] or lastResyncTime[contextId] == nil
				changes = prepareUpstreamChanges(contextId)
				waitingForData[contextId] = true
				// dbSync can be "full request" (time = -1) which gets all data, 
				// or "diff" where you get all changes since X seconds, and if
				// there's no changes, the server will wait for changes (comet) 
				handle = dbSync(contextId, doFullRequest and -1 or floor(serverClientTimeFudge + getTime() - lastResyncTime[contextId]), toJSON(changes), func err, requestedDataInJSON { 
					if err or requestedDataInJSON == '' or substring(requestedDataInJSON, 0, 3) == "ERR" {
						// if we reload the page in chrome, it seems like the http result will return empty string before the new page is loaded
						// failed to sync local data to server...
						if err == 'abort' and not isCometWaiting[contextId]  {
							throw('unexpected abort')
						} else if err == 'abort' and isCometWaiting[contextId] { // this is not considered an error
//							print("comet abort!")
							isCometWaiting[contextId] = nil
						} else {
							print("error timeout! will try again")
							errCount[contextId] = (errCount[contextId] or 0) + 1
							if errCount[contextId] >= 8 { throw('Uploading sync of '..contextId..' failed!') }
							for _,v in changes {
								upstreamStateUpdates[contextId][v.id] = idToNode[v.id] // ...so try again next interval
							}
						}
					} else {
						if requestedDataInJSON == 'comet timeout' {
//							print("comet timeout, should create new comet shortly...")
							isCometWaiting[contextId] = nil
						} else {
//							print("PATCH!"..requestedDataInJSON)
							patchDiff(requestedDataInJSON, contextId)
							forceFullResync[contextId] = nil
							errCount[contextId] = nil							
						}
					}
					waitingForData[contextId] = nil
				})
				if not hasChanges and not doFullRequest { isCometWaiting[contextId] = handle }
				lastResyncTime[contextId] = getTime() 
			}
		}
	})

*/
	
/* NOTES

	     code tree format == each item in plain text
	BUT  what about diffable state data format? use json?

	are there standards for json diff/patch?

		http://tlrobinson.net/projects/javascript-fun/jsondiff
		{                                      
			"path": "/features/2/geometry/coordinates/0",
			"value": -122.655,
			"op": "replace"
		},

		https://github.com/benjamine/JsonDiffPatch              
		{
        "name":["Argentina","Repblica Argentina"], // old value, new value
        "population":["41324992"], // new value
        "capital":["Buenos Aires",0,0] // deleted
   		}


[{timeStamp = 823749, inverseDiff = ...}, ...]

{a:{b:10}}
{a:{b:[]}}     --> inverse {a:{b:10}}
{a:{b:{c:20}}} --> inverse {a:{b:[]}}

"526495b300Vf0fdd2Ew" : {"id":"526495b300Vf0fdd2Ew","time":1388392425,"pId":"ID_root","sPr":"WWWWZ","dat":"Peace man"},

"526495b300Vf0fdd2Ew" : {"time":1388392425,"pId":"ID_root","sPr":"WWWWZ","dat":"Peace man"},

db = createDB('myDB')
db.listen()
db.getChangesSinceSeconds(2)
db.set('526495b300Vf0fdd2Ew', { a = 1, b = 'string', someArray = [1,2,3,4,5] })
db.get('526495b300Vf0fdd2Ew')


what about app state history and snapshots?


		if not upstreamStateUpdates[contextId] {
			upstreamStateUpdates[contextId] = { }	

window.onhashchange = function(e) {
  alert(location.hash);
};
location.hash='rreg6'

'Lr2X6jw=='

	user cases:
	- static precompiled database, no backend
	- state as html URI fragment                             app <-> db
	- database file on server / local diff
	- database file on server + comet / local diff
	- huge database / diff to server


	baseDB = createDB()
	appDB = createDiffDB(baseDB)


	createSyncedTreeDB
	ctx = stapi.addContext('encryptedDB', stateSyncedTreeDBAsEncryptedFile)

	ctx = stapi.addContext('encryptedDB', stateSyncedTreeDBAsFile)
	
	sync to URL

	syncTime

	onInterval(3, func {
		if ctx.hasChanged() {
			ctx.getChangeDiff()
		}
	})

*/

/*
	addContext = func contextId, doPoll {
		contexts[contextId] = true
		forceFullResync[contextId] = true
		doPolling[contextId] = doPoll
		if not upstreamStateUpdates[contextId] {
			upstreamStateUpdates[contextId] = { }
		}
	}

//	nextNode = func o { assert(o.parent) ; assert(o.parent['tSubnodes']) ; o['tNext'] != o.parent['tSubnodes'] and o['tNext'] }
//	prevNode = func o { assert(o.parent) ; assert(o.parent['tSubnodes']) ; o['tPrev'] != o.parent['tSubnodes'] and o['tPrev'] }

	nextNode = func o { assert(o.parent) ; assert(o.parent['tSubnodes']) ; llGet(o.parent['tSubnodes'], o, 'tNext') }
	prevNode = func o { assert(o.parent) ; assert(o.parent['tSubnodes']) ; llGet(o.parent['tSubnodes'], o, 'tPrev') }
	
	return {
		setGlobalCallbacks = func nodeInit, nodeDelete { onNodeInit = nodeInit ; onNodeDelete = nodeDelete }
		addContext         = addContext
		pushCurrentContext = func ctx { push(defaultContext,ctx) }
		popCurrentContext  = func { pop(defaultContext) ; if len(defaultContext) < 1 { throw('popCurrentContext() called to many times!') } }

		createNode         = createNode
		getNode            = func id { idToNode[id] }
		deleteNode         = func n { set(n.parentId, '') ; tapi.traverse(n, func nn { set(nn.parentId, '') }) ; n.updateTreelocation() }

		connectObserver    = connectObserver
		removeObserver     = removeObserver

		insertFirst        = func parent, ins { assert(parent)     ; set(ins.parentId, parent.id)     ;                      set(ins.sortPrio, generateSortPrioBetween(nil, tapi.hasSubnodes(parent) and get(tapi.first(parent).sortPrio))) ; ins.updateTreelocation() }
		insertLast         = func parent, ins { assert(parent)     ; set(ins.parentId, parent.id)     ;                      set(ins.sortPrio, generateSortPrioBetween(tapi.hasSubnodes(parent)  and get(tapi.last(parent).sortPrio), nil)) ; ins.updateTreelocation() }
		insertBefore       = func rel, ins    { assert(rel.parent) ; set(ins.parentId, rel.parent.id) ; pr = prevNode(rel) ; set(ins.sortPrio, generateSortPrioBetween(pr and get( pr.sortPrio),      get(rel.sortPrio)))                   ; ins.updateTreelocation() }
		insertAfter        = func rel, ins    { assert(rel.parent) ; set(ins.parentId, rel.parent.id) ; ne = nextNode(rel) ; set(ins.sortPrio, generateSortPrioBetween(get(rel.sortPrio),      ne and get( ne.sortPrio)))                   ; ins.updateTreelocation() }

		next               = nextNode
		prev               = prevNode
		first              = tapi.first
		last               = tapi.last
		parent             = func n { n.parent }
		
		traverseSubnodes   = tapi.traverseSubnodes
		traverseSubnodesR  = tapi.traverseSubnodesR
		traverse           = tapi.traverse   	// call ->  recurse forwards           (pre order)
		traverseR          = tapi.traverseR     // call ->  recurse backwards          (pre order, reverse)
		traverseP          = tapi.traverseP     //          recurse forwards  -> call  (post order)
		traversePR         = tapi.traversePR    //          recurse backwards -> call  (post order, reverse)
		traverse2          = tapi.traverse2     // call1 -> recurse forwards  -> call2 (2 functions)
		traverse2R         = tapi.traverse2R    // call1 -> recurse backwards -> call2 (2 functions, reverse)
	}
}

*/

/* NOTES

	sync to a virtual file system -  pure http get access, very good read scaling,
									 very bad write scaling, full history "forced",
									 no comet style "hooks"
 	server disk:
	
		contextName/version					// contains the current version string/filename and points to a block-index-file
		contextName/3WN4CANSUDC				// block-index-file, "LKDSFJV53LS\n\nI9OEVM673GS JOD6EF3SFNV"
		contextName/JOD6EF3SFNV		        // allocated block
		contextName/LKDSFJV53LS				// block-index-file, "\n\nI9OEVM673GS R3VNE7JSFB5" (used for history only)
		contextName/R3VNE7JSFB5	        	// allocated block (used for history only)
		contextName/I9OEVM673GS				// allocated block
		
	Writing to a context, you supply
		oldVersion=3WN4CANSUDC&       		// filename of previous block-index-file
		block0=...&block1=...&         		// One or several datafiles (referenced by block id)
		link2=1                     		// relink block index
		lastBlockId=1
		
	
---------		
	sync to a virtual file system -  Append, items can change order, but items are never missed
 	server disk:
	
		contextName/version					// contains the current version, points to the datafile, for instance 3WN4CANSUDC
		contextName/3WN4CANSUDC				// data changes log, it is the clients job to flatten it
		contextName/LKDSFJV53LS				// data changes log (old)

	sync
	
		sync?version=3WN4CANSUDC&offset=1200
		sync?version=3WN4CANSUDC&offset=1200&add=...
		
	Meta File-contents:
		
		Meta_YOD6EF3SFNV
		I9OEVM673GS
		3WN4CANSUDC
		LKDSFJV53LS
  	
	Writing to a context, you supply
		old Meta file
		One or several datafiles (referenced by block id)
		** Authentication for writing to context
   		 OR
		** ADMIN Authentication (writing to all contexts + creating new contexts)
	
	global functions:
		getTimeStamp.php
		getPublicWriteKey.php
		
	
	encryption of dbSync (change input "changes" to be dnative objects instead of JSON text)
	
		blockSize = 4096
		blocks = {}
		dbSyncToBlocks = function(ctxId, timeDiff, changes, f) {
			if not blocks[ctxId] {
//				return http('db/' .. ctxId, {}, func {	}) // would be nice with pure access, but seem risky to injection, and return mime type mess
				return http('dbSyncToBlocks.php', { sendData = "ctxId="+ctxId}, func err, data {
					
				})			
			}
			 = blocks[ctxId] or [{}]
			lastBlock = last(blocks[ctxId])
			for _,v in changes {
				if not lastBlock[v.id] {
				} else {
				
				}
			}
//			return http('dbSync.php', { sendData : "ctxId="+ctxId+"&timeDiff="+timeDiff+"&data="+encodeURIComponent(toJSON(changes))}, f)

		},
	
*/


#####

api calcNodeDepthDiff = func stapi, n1, n2 {
	i = 0
	it = n2
	while(it) {
		if it == n1 { return i }
		it = stapi.parent(it)
		i = i + 1
	}
}
	
#####

gHookContext = createHookContext()




#####

	api createCallbackList = func {
		l = nil
		return {
			register = func f {
				l = l or llCreate('prev', 'next')
				item = {f = f}
				item.remove = func { llUnlink(item, 'prev', 'next') }
				llInsert(l, item, 'next', 'prev')
				return item
			}
			sendCallbacks = func {
				llForEach(l, func item {
					item.f()
				}, 'prev', 'next')
			}
			remove = func { // this removes all
				if l != nil {
					firstItem = llGet(l, 'next')
					while firstItem {
						llUnlink(firstItem, 'prev', 'next')
						firstItem = llGet(l, 'next')
					}
					l = nil
				}
			}
		}	
	}

#####

	api drawEvent = createCallbackList()
	global guiDraw = func { drawEvent.sendCallbacks() }

#####

    framesN = 0
	api frameCount = func { framesN }
	api idleEvent = createCallbackList()
	global guiIdle = func { framesN = framesN + 1; idleEvent.sendCallbacks() }


#####


api createScheduler = func {
	t = 0
	items = [] // If event count is high, we better use a sorted linked list to optimize flush
	createSchedulerItem = func time, f {
			item = {t = t + time, f = f}
			item.remove = func { item.del = true }
			push(items, item)
			item
		}
	return {
		delay      = createSchedulerItem
		onInterval = func time, f { item = createSchedulerItem(time, f) ; item.intt = time ; item }
		flush      = func time {
			t = t + time
			for i * len(items) {
				item = items[i]
				if item.del {
					items[i] = nil
				} else {
					if item.t < t {
						item.f(time) // tryCall here?
						if item.intt != nil {
							item.t = item.t + item.intt
							if item.t < t { item.t = t } // drop events if requested interval time is less than the time between flushes
						} 
						else {
							items[i] = nil
						}
					}
				}
			}
			findAndRemove(items, nil)
		}
	}
}

#####


api createFrameState = func scheduler, frameEvent {
	lastDiff = 1/10000
	prevTime = 0
	fixedFps = nil
	advanceFrame = func inTime {
		t = 0
		diff = 0

		if prevTime == 0 {
			prevTime = inTime
		}

		if fixedFps == nil {
			t = inTime
			diff = t - prevTime
		} else {
			diff = 1 / fixedFps
			t = prevTime + diff
		}

		lastDiff = diff
		prevTime = t
		frameEvent.sendCallbacks() 
		assert(diff, '>=', 0)
		if diff > 0 {
			scheduler.flush(diff)
		}
	}	
	return {
		advanceFrame = advanceFrame
		setFixedFps = func fps { fixedFps = fps}
		time = func { prevTime }
		deltaTime = func { clamp(lastDiff, 0.00000001, 1/5) } // don't report zero frame time or fps lower than 5
	}
}

#####

api newFrameEvent = createCallbackList()
standardScheduler = createScheduler()
standardFrame = createFrameState(standardScheduler, newFrameEvent)

api delay = standardScheduler.delay
api onInterval = standardScheduler.onInterval
api killTimer = remove

api setFixedFps = standardFrame.setFixedFps
api frameDeltaTime = standardFrame.deltaTime
api frameTime = standardFrame.time


api flushTimers = func { standardFrame.advanceFrame(getTime()) }


#####


inited = false
api initGlobalTimers = func {
	
	if not inited {
		inited = true
		idleEvent.register(flushTimers)	
	}
	
}


#####

api createSyncedFunc = func hc, f, args {
	out = create()
	hookMultiple(hc, args, 0, func { set(out, callWithArgs(f, map(get, args) )) } )
	out
}

// only const       - don't hook
// const, normal    - hook args + hook inverse to change normal
// normal, normal   - hook args + function defined inverse behaviour 

#####

api countPadding = func s, padChar {
	assert(padChar)
	ss = len(s)
	for i = 0, ss {
		if substring(s, i, i+1) != padChar {
			return i
		}
	}
	ss
}

#####

api connectRecursiveObserver = func stapi, subjectRoot, observer, f {
	hooks = {}
	deepMoved = {}
	observing = {}
	recInsert = nil
	recInsert = func event, n {
		id = n.id
//		print(event .. ' ' .. id .. ' ' .. deepMoved[id] .. ' ' .. observing[id])
		if event == 'subnodeInserted' {
		
			if deepMoved[id] {
				deepMoved[id] = nil
			} else {
				if observing[id] == 'blockReentry' {
					return // is this correct? sure, we don't wanna connect twice, but why do we get a reentry with the same idea?
				}
				assert(observing[id] == nil)
				observing[id] = 'blockReentry'  // connectObserver can cause reentry
				observing[id] = stapi.connectObserver(n, observer, recInsert)
			}

		} else if event == 'subnodeRemoved'   {
			// n was removed from it's parent, but it might be moved 
			// to another node within our observed sub-tree
			// here we detect that case, and notify with a special event 'subnodeDeepMoved':

			if calcNodeDepthDiff(stapi, subjectRoot, n) {
				deepMoved[id] = true
				f('subnodeDeepMoved', n)
				return
			}
			
			assert(observing[id], '!=', nil)
			h = observing[id]
			observing[id] = nil  // removeObserver can cause reentry
			stapi.removeObserver(h)
			
		} else if event == 'subnodeMoved' {
		}
		f(event, n)
	}
	stapi.traverse(subjectRoot, func n { 
		observing[n.id] = stapi.connectObserver(n, observer, recInsert)
	})
	return {observing = observing, hooks = hooks}
}

#####

api syncTextWithSubTree = func stapi, root, textObj {
	hctx = createHookContext()
	treeChanged = true
	textChanged = false
	oldText = nil
	oldLines = ['']
	oldNodesIds = []
	treeChangeSinceLastSync = {}
	nodeIdToHook = {}
	sync = func {
		if textChanged and oldText == get(textObj) { textChanged = false } 
		if treeChanged or textChanged {	
			if textChanged and oldText != nil {
				allText = get(textObj)
				allText = findAndReplace(allText, '\t', ' ')
				newLines = split(allText, '\n')
				newS = len(newLines)
				oldS = len(oldLines)
				diffStart = 0
				cnt = min(newS, oldS)
				while diffStart < cnt and newLines[diffStart] == oldLines[diffStart] { diffStart = diffStart + 1 }
				diffEnd = 1
				while diffEnd <= cnt and newLines[newS - diffEnd] == oldLines[oldS - diffEnd] { diffEnd = diffEnd + 1 }
				prevNode = diffStart > 0 and stapi.getNode(oldNodesIds[diffStart - 1])
				for i = diffStart, newS - diffEnd {
					if treeChangeSinceLastSync[oldNodesIds[i]] {
						// do nothing, text changes will be lost, could prob diff the actual text here, if we want...
					} else {
						node = i <= oldS - diffEnd and stapi.getNode(oldNodesIds[i]) or stapi.createNode()
						depth = countPadding(newLines[i], ' ')
						newData = substring(newLines[i], depth)      //; print("updated from text: "..newData)
						set(node.data, newData)
						if prevNode {
							if depth == 0 { // new line
								if stapi.first(prevNode) { stapi.insertFirst(prevNode, node) }
								else                     { stapi.insertAfter(prevNode, node) }
							} else {
								depthDiff = depth - calcNodeDepthDiff(stapi, root, prevNode)
								afterOldPos = (calcNodeDepthDiff(stapi, root, node) - depth == 1) and stapi.next(node)
								if depthDiff == 0 and node != stapi.next( prevNode) {
									stapi.insertAfter(prevNode, node)		//; print('insert after '..get(prevNode.data)) 
								} else if depthDiff > 0 and node != stapi.first(prevNode) {
									stapi.insertFirst(prevNode, node) 		//; print('insert first '..get(prevNode.data)) 
								} else if depthDiff < 0 and depth > 0 {
									tmpNode = prevNode
									for j = 1, -depthDiff { tmpNode = stapi.parent(tmpNode) }
									if node != stapi.next(tmpNode) {
										stapi.insertAfter(tmpNode, node)	//; print('insert after '..get(tmpNode.data))
									}
								}
								if afterOldPos {
									tmp = stapi.next(afterOldPos)
									stapi.insertLast(node, afterOldPos)
									pNode = afterOldPos
									afterOldPos = tmp
									while(afterOldPos) {
										tmp = stapi.next(afterOldPos)
										stapi.insertAfter(pNode, afterOldPos)
										pNode = afterOldPos
										afterOldPos = tmp
									}
								}								
							}
						} else {
							stapi.insertFirst(root, node)
						}
						prevNode = node						
					}
				}
				for i = newS - diffEnd + 1, oldS - diffEnd {
//					print("deleted from text: "..get(stapi.getNode(oldNodesIds[i]).data))
					stapi.deleteNode(stapi.getNode(oldNodesIds[i]))
				}
			}
			
			oldNodesIds = []
			oldLines    = []
			stapi.traverse(root, func n {
				if root != n {
					push(oldNodesIds, n.id)
					push(oldLines, rep(' ', calcNodeDepthDiff(stapi, root, n)) .. get(n.data))
				}
			})
			oldText = arrayConcatToString(oldLines, '\n')
			set(textObj, oldText)
			treeChanged = false
			textChanged = false
			treeChangeSinceLastSync = {}
		}
	}
	hook(hctx, textObj, func { textChanged = true; later(sync) })
	invalidateSync = func id { treeChangeSinceLastSync[id] = true ; treeChanged = true; later(sync) }
	recObs = connectRecursiveObserver(stapi, root, root, func event, n {
		if      event == 'subnodeInserted' { nodeIdToHook[n.id] = hook(hctx, n.data, func { invalidateSync(n.id) } ) }
		else if event == 'subnodeRemoved'  { unhook(nodeIdToHook[n.id]) }
		invalidateSync(n.id)
	})
}


#####

/*
	
	// IMPL FUNCTION CALL!
	
	// ability to define function-pairs  split/join  exp/log
	// should operand-spec just be an option of that functionality?
	
	// how to impl vector-reducing functions such as min, max to support both lists and arrays cleanly 

	// how to impl vectorization based on arguments of a function, 
	
	// managed objects, think about bitmaps for instance, or data rendered by C code
	// expression might be crop(loadImage('IMG'..i..'.png'), 0, 0, width, height)
	// {__type = 'bitmap', __internId = "image('IMG23.png')"}
	// {__type = 'bitmap', __internId = "crop(image('IMG23.png'), 0, 0, 256, 256)"}
	
	// {_im:new Image(), x = 0, y = 0, w = 100, h = 50}
	// {__type = 'bitmap', __internId = "getImage('IMG23.png')"}
	
	// ['someText', 666]                                       // hook detects any change,  need to deepequal
	// {__type='list' __id='5Du82f21ht3cnG4a' }                // hook detects change of entire listobject
	// {__type='list' __id='5Du82f21ht3cnG4a', __version=415 } // hook detects any change
	// {__type='list' __id='5Du82f21ht3cnG4a', size = 2 }      // hook detects change of list structure or entire listobject
	// {__type='list' __id='5Du82f21ht3cnG4a', data = ['someText', 666] } // hook detects any change
	// {__type='list' __id='5Du82f21ht3cnG4a', __internId = "['someText', 666]" } // ??

	// one item in the list cannot be hooked, id's are irrelevant,
	// need "insert/removed" callbacks, then we need references to 'slots'
	// what kind of referenses ?
	

entire = structure + all items
 streamed functions:
  * concat, hook entire arguments, stream out
  * index, hook that index
  * min / max,  hook entire, store last out
  * median / average, 

 streamed primitives?                         SIMPLEST CASE         COPY ON WRITE
	ordered_map = {  
        create                                { {} }                { {__type = "ordered_map", m = {} } }	
		index string_or_number                { m[k] }              { m.m[k] }
		insert string_or_number, any          { m[k] = v }          { if m.readOnly { m = deepcopy(m) ; m.readOnly = false } m.m[k] = v } 
		remove string_or_number               { m[k] = nil }        { if m.readOnly { m = deepcopy(m) ; m.readOnly = false } m.m[k] = nil }
		copy                                  { deepcopy(m) }       { m.readOnly = true; return m }
		remove                                { }                   { }
	}
	
	                                          REFCOUNTED
											  
        create                                { {__type = "ordered_map", m = {}, shared = 0 } }	
		index string_or_number                { m.m[k] }
		insert string_or_number, any          { if m.shared > 0 { m = deepcopy(m) ; m.shared = 0 } remove(m.m[k]); m.m[k] = v } 
		remove string_or_number               { if m.shared > 0 { m = deepcopy(m) ; m.shared = 0 } remove(m.m[k]); m.m[k] = nil }
		copy                                  { m.shared = m.shared + 1; return m }
		remove                                { m.shared = m.shared - 1;
	
	
	create                                { {__type = "ordered_map", m = {}, shared = 0 } }	
	index string_or_number                { m.m[k] }
	insert string_or_number, any          { if m.shared > 0 { m = deepcopy(m) ; m.shared = 0 } remove(m.m[k]); m.m[k] = v } 
	remove string_or_number               { if m.shared > 0 { m = deepcopy(m) ; m.shared = 0 } remove(m.m[k]); m.m[k] = nil }
	copy                                  { m.shared = m.shared + 1; return m }
	remove                                { m.shared = m.shared - 1;
	
	//     1+(3) vs sill(3)
	// sill([3]) vs sill(3)
	// (3,1)
	
	obj = [{value = 4, fun = sin}, {value = 5, fun = cos}]
	abs(obj.*.value)
	obj.*.fun(3)
	obj.*.fun(3,2)
	
	(3)          modelObj<number>     3
	(3,2)        modelObj<rtArray>    rtArray    [3, 2]
	obj          modelObj<rtArray>    rtArray    [rtArray[value = 4, fun = rtFuncDS..], rtArray[value = 5, fun = rtFuncDS..]]
	obj.*        modelObj<rtArrayAll> rtArrayAll [rtArray[value = 4, fun = rtFuncDS..], rtArray[value = 5, fun = rtFuncDS..]]
	obj.*.value  modelObj<rtArrayAll> rtArrayAll [4, 5]
	obj.*.fun    modelObj<rtArrayAll> rtArrayAll [rtFuncDS.., rtFuncDS..]
	
	functor = func
	
	rtArray = {
		__class = {
									// functor_connect ?
			functor = func indexObj
		}
	}
	
	rtFuncDS = {
	}
	





	
	parseExpression is expected to return {data = <from callback>, tree = [...] }
	
	 "1 +  2 // comment" 
	 
		{symbol = '+', data = 3, ws = '  ',
			left = {t = 'number', data = 1, ws = ' ' }, 
			right = {t = 'number', data = 2, ws = ' // comment' },  }
									
	 "f1(4, 5 + f2(6))" 

		{t = 'call', data = 15, 
			left = {t = 'function', data = <function object>, symbol = 'f1'},
			right = {t = 'array', data = [4,11], ws = ' // comment' },  }
			


	       A       B    
	   (   |   +   |   ) 
	   
	   
	   
	       A       B    
	       |   +   |    
	           |       )
	   (               | 

	  
	   (   A   +   B   ) 
	 0 ( 1 A 2 + 3 B 4 ) 5
	 
	 ? ( ? A_2 +_3 B_4 )_5
	 

	
*/	
//	brackets = { '(' = ')', '[' = ']', '{' = '}' } 
	endBracket = { +')', +']', +'}' } 
	dataIdCounter = 0
	itemsIdCounter = 0
	api resetParserDataIdGenerator = func { dataIdCounter = 0 ; itemsIdCounter = 0 }
	generateDataId  = func { dataIdCounter  = dataIdCounter  + 1 ; return dataIdCounter}
	generateItemsId = func { itemsIdCounter = itemsIdCounter + 1 ; return itemsIdCounter}
	tryToParseAssignment = func it {
		kTmp = nil
		tokAsData = nil
		tok = it.peek()
		if tok {
			tokIsString = tok == '"' or tok == "'"
			tokIsDigit = isDigit(charCodeAt(tok,0)) // todo support negative?
			if isAlpha(charCodeAt(tok,0)) or tokIsDigit or tokIsString {  // case to handle simple assignment to alphanumeric tokens
				pos = it.getTokenPos()
				if tokIsString {
					_ws1 = it.proceed(true)
					tok = it.parseQuotedString()
					tokAsData = fromJSON('"'..substring(tok,1,-1)..'"') // TODO: FIX CORRECT UNESCAPING
				} else if tokIsDigit {
					tokAsData = toNumber(tok)
					_ws1 = it.proceed()
				} else {
					_ws1 = it.proceed()
				}
				if it.peek() == '=' {
					_ws2 = it.proceed()
					kTmp = { token = tok }
					if tokAsData != nil { kTmp.tokenAsData = tokAsData }
					if _ws1 != '' { kTmp.ws1 = _ws1 }
					if _ws2 != '' { kTmp.ws2 = _ws2 }
				} else {
					it.setTokenPos(pos)
				}
			}		

		}
			return kTmp
	}
	parseExpressionR = nil
	parseStatement = func it, parseContext {
		if it.peek() == nil { return }
		beginPos = it.getTokenPos()
		kTmp = tryToParseAssignment(it)
		tmp = parseExpressionR(it, 0, parseContext) // hardcoded prec  (should be same as parseExpression, right?)
		if it.peek == '=' { throw('unexpected trailing assignment') }
		if kTmp {
			tmp = {left = kTmp, token = '=', right = tmp}  // this is assignment
		}		
		if not (beginPos == 0 and it.peek() == nil) {
			tmp.beginPos = beginPos
			tmp.endPos = it.getTokenPos()			
		}
		return tmp		
	}
	api parseStatements = nil
	api parseStatements = func it, parseContext {
		out = { codeTreeArray = [] }
		if it.peek() == nil {
			ws = it.proceed()
			if ws != '' { out.wsOnly = ws }
		} else {
			while true {
				codeTree = parseStatement(it, parseContext)
				if codeTree == nil {
					break
				}
				push(out.codeTreeArray, codeTree)
				token = it.peek()
				if token == '-->' or token == '<--' or token == ';' {
					it.proceed()
					codeTree.divider = token
					if      token == '-->' { codeTree.subTree = parseStatements(it, parseContext) }
					else if token == '<--' { break }
				} else {
					break
				}
			}			
		}
		out
	}
	parseExpressionR = func it, prec, parseContext, isFunctorArg, injectedBracketScope {
		t = it.peek()
//		print('parseExpressionR TOKENPOS '..it.getTokenPos()..' '..t..' '..toStr(isFunctorArg))

		if t == nil { throw('parseExpressionR unexpected end of expression') }
		
		if endBracket[t] { throw('end bracket not expected:'..t..'') } 
		e = {}
		
		injectBracket = isFunctorArg and (it.rawPeek(-1) == ' ' or t != '(' and t != '[')
		if not injectBracket {
			ws = it.proceed(true) ; if ws != '' { e.ws1 = ws }
		}
		
		brack = parseContext.brackets[t]
		if injectBracket or brack and prec < brack.prec {
			if not injectBracket { it.proceed() }
			tmp = nil
			items = nil
			if not injectBracket and it.peek() == brack.end { 
				if not isFunctorArg and t == '(' and it.peekAhead(2) != '=>' {
					throw('unclear intent, empty brackets only expected for functor')
				}

				 // () function call empty bracket 

				bws = it.proceed(true)
				if bws != '' { e.wsEmptyBracket = bws }
				e.items = []
				e.itemsId = generateItemsId()
			} else {
				while true {
					kTmp = tryToParseAssignment(it)
					tmp = parseExpressionR(it, 0, parseContext, false, injectBracket) // hardcoded prec  (should be same as parseExpression, right?)
					if it.peek == '=' {
						if kTmp != nil { throw('unexpected double assignment') }
						kTmp = tmp
						tmp = parseExpressionR(it, 0, parseContext, false, injectBracket) // hardcoded prec  (should be same as parseExpression, right?)
					} 

					if kTmp {
						tmp = {left = kTmp, token = '=', right = tmp}  // this is a key / value pair
					}

					moreItems = it.peek() == ','  // how support nil (end of line)
					if moreItems or kTmp or injectBracket { 
						items = items or []
					} 

					if items {
						push(items, tmp)					
					}

					if moreItems {
						it.proceed()
					} else {
						break
					}
				}
				if items {
					e.items = items
					e.itemsId = generateItemsId()
				} else if not isFunctorArg and t == '(' {		
					if tmp.ws1 == nil and tmp.ws2 == nil and tmp.leftBracket == nil { // try to reduce data structure depth
						e = tmp
						tmp.ws1 = ws
					} else {
						e.right = tmp    // left or right?
					}
				} else {
					e.items = [tmp]
					e.itemsId = generateItemsId()
				}
			}
			if not injectBracket {
				if it.peek() != brack.end { throw('mismatching bracket, expected '..e.rightBracket..' or comma. Got '..it.peek()..' '..it.getStringForError()) }
				if it.proceed() != '' { throw('unexpeceted whitespace') }
				e.leftBracket = t
				e.rightBracket = brack.end
//				if brack.callback { e = brack.callback(e) }
			} else {
				e.leftBracket = ''
				e.rightBracket = ''	
//				if parseContext.brackets[''].callback { e = parseContext.brackets[''].callback(e) }
			}
		} else if t == "'" or t == '"' {
			e.string = fromJSON('"'..substring(it.parseQuotedString(),1,-1)..'"') // TODO: FIX CORRECT UNESCAPING
			e.dataId = generateDataId()
			if parseContext.outData { parseContext.outData[e.dataId] = e.string }
//			e.data = parseContext.string.callback(text)
		} else if t and (isDigit(charCodeAt(t,0)) or (t == '-' and isDigit(charCodeAt(it.rawPeek(1),0)) ) or parseContext.dataTokens[t]) {
			if parseContext.dataTokens[t] { // NaN Infinity etc
				e.number = parseContext.dataTokens[t] 
			} else if t == '-' {
				// since we support reverse parsing, we need to handle this case here and not just pass it to unary minus
				//  (otherwise minuses will accumulate each time the value goes from positive to negative)
				e.number = -toNumber(it.rawPeek(1))	
				it.proceed()
			} else {
				e.number = toNumber(t)	
			}
			if not injectBracket { it.proceed() }
			e.dataId = generateDataId()			
			if parseContext.outData { parseContext.outData[e.dataId] = e.number }
//			e.data = parseContext.number.callback(t)

		} else if parseContext.unaryOperators[t] {
			if not injectBracket { it.proceed() }
			una = parseContext.unaryOperators[t]

			if una.prec > prec { // this check is not needed for C style syntax (for purist math -2^2 should be -4, note that this still fails for constants when precedence is set lower, as minus is parsed as a part of the number if there is no whitespace between)
				e.token = t
				e.right = parseExpressionR(it, una.prec, parseContext, false, injectBracket)
	//			e.data = una.callback(e.right.data)
			}

		} else {
			if not injectBracket { it.proceed() }
			e.token = t
//			e.isSymbol = true
		}
		
		ws = it.proceed(true) ; if ws != '' { e.ws2 = ws }
		
		
		while true {
			t = it.peek()
			if	t == nil or
				parseContext.terminators[t] or 
				endBracket[t] or 
				injectedBracketScope and parseContext.injectedBracketTerminators[t]
			{
				return e
			} 
			
			op2 = parseContext.binaryOperators[t]

			// guess if unary or binary based on whitespace, this behaviour
			// is pretty weird, however it still seems to be the best option...
			// (coffeescript does something similar)

			//  a-b   ->  a - b   guessUnary = false 
			//  a- b  ->  a - b   guessUnary = false 
			//  a - b ->  a - b   guessUnary = false 
			//  a -b  ->  a(-b)   guessUnary = true 
			
			guessUnary = op2 and parseContext.unaryOperators[t] and it.rawPeek(-1) == ' ' and it.rawPeek(1) != ' '

			if op2 and not guessUnary { 

				if op2.prec > prec or op2.isRightAssoc and op2.prec == prec {
					nextPrec = op2.prec - (not op2.isRightAssoc and op2.prec == prec ? 1 : 0)
					it.proceed()
					e = {
						left = e
						token = t
						right = parseExpressionR(it, nextPrec, parseContext)
					}
//					e.data = op2.callback(e.left.data, e.right.data)
				} else {
					break
				}
//			} else if parseContext.unaryPostOperators and parseContext.unaryPostOperators[t] and prec < parseContext.unaryPostOperators[t].prec {

			} else if prec < parseContext.binaryOperators[''].prec { // case for functor operator
				e = {
					left = e
					token = '' // empty token means the functor operator
					right = parseExpressionR(it, parseContext.binaryOperators[''].prec, parseContext, true)
				}
//				e.data = parseContext.functor.callback(e.left.data, e.right.data)				
			} else {
				break
			}

		}
		return e
	}


//	txtToASTCache = {}


	api defaultParseContext = func {
		{
			brackets = {
				'('      = { prec = 38, end = ')' } 
				'['      = { prec = 33, end = ']' } 
				'{'      = { prec = 34, end = '}' } 
			}
			unaryOperators = {
				'-'      = { prec = 24 } // note: setting this lower will still fail for constants, as minus is parsed as a part of a number if there is no whitespace between (to avoid accumulating unary minus operators when reverse-parsing) 
				'/'      = { prec = 24 } // is there a reason programming languages don't have unary div?   seems useful! And also -more symmetrical hehe 
				'~'      = { prec = 24 } 
				'not'    = { prec = 24 }
			}
			binaryOperators = {
				'.'      = { prec = 30 }
				''		 = { prec = 28 } // functor
				'^'      = { prec = 22  , isRightAssoc = true}
				'*'      = { prec = 20 }
				'**'     = { prec = 20 } // use for complex numbers and matrices? operator overloading is more powerful... 
				'/'      = { prec = 20 }
//				'/%'     = { prec = 20 } // drop c style comments to use // for integer division? (lua / python)
				'%'      = { prec = 19 }
				'%%'     = { prec = 19 }
				'+'      = { prec = 18 }
				'++'     = { prec = 18 }
				'-'      = { prec = 18 }
				'--'     = { prec = 18 }
				'>>'     = { prec = 17 }
				'<<'     = { prec = 17 }
				'....'   = { prec = 16 }
				'...'    = { prec = 16 }
				'..'     = { prec = 15 }
				'>'      = { prec = 15 }
				'<'      = { prec = 15 }
				'>='     = { prec = 15 }
				'<='     = { prec = 15 }
				'=='     = { prec = 15 }
				'!='     = { prec = 15 }
				'&'      = { prec = 14 }
				'~'      = { prec = 13 }
				'|'      = { prec = 12 }
				'and'    = { prec = 11 }
				'or'     = { prec = 11 }
				'|>'     = { prec = 10 } 
				'->'     = { prec = 9  } 
				'<|'     = { prec = 8  } 
				':'      = { prec = 7 , isRightAssoc = true}
				'?'      = { prec = 7 , isRightAssoc = true}
				'=>'     = { prec = 6 , isRightAssoc = true} 
				'<-'     = { prec = 5  } // write operator
				'>>>'    = { prec = 4  } // debug operator
				'='      = { prec = 3  , isRightAssoc = true}
				','      = { prec = 2  }
				'apply'	 = { prec = 1  } // functor apply   remove?  more clear to use apply(func, args) than "(func apply args)"
			}
			terminators = {  // note: end-brackets are always terminators
				','      = 1
				';'      = 1
				'-->'    = 1  // remove? (spine-specific so add from there, but also maybe bad idea overall (syntax to push things into differeny levels of the block tree from a single line))
				'<--'    = 1  // remove? (spine-specific so add from there, but also maybe bad idea overall (syntax to push things into differeny levels of the block tree from a single line))
			}			
			injectedBracketTerminators = {
				'<-'     = 1
				'->'     = 1
				'|>'     = 1
				'<|'     = 1
				'>>>'    = 1
			}	
			dataTokens = { 
				'NaN'    = 0/0     // add infinity?  parser then needs special treatment for minus...
				'???'    = 97397421387 
			}			
			outData = {}
		}			
	}

	api parseToAST = func txt, cb {
//		calcedBefore = txtToASTCache[txt]
//		if calcedBefore {
//			return calcedBefore
//		}
		cb = cb or defaultParseContext()
		resetParserDataIdGenerator()
		it = createTokenIterator(parseToTokens(txt))
		res = parseStatements(it, cb)
		res.dataVals = cb.outData
//		txtToASTCache[txt] = res
		return res
	}





	
	// (a + b)  (a + b, 1) (1,2)
	// [a + b]  [a + b, 1] [1,2] 
	// brackets = {
	//   '[' = { createCallback = func {}, insertCallback = func key, value { if key == nil { insert(curObj, value) } else { set(curObj, key, value) } }

	//  token        :   ws1 leftBracket <rec>    token       <rec> rightBracket ws2
	//  data         :   ws1 leftBracket <rec> unparseData(t) <rec> rightBracket ws2
	//  bracket      :   ws1 leftBracket <rec>  ...........   <rec> rightBracket ws2
	//  empty bracket:   ws1 leftBracket <rec> wsEmptyBracket <rec> rightBracket ws2

	api unparseExpression = func out, tree, unparseData, unparseItems {
		unparseData = unparseData or func t { t.number != nil and t.number or t.string }
		unparseRec = nil
		unparseRec = func t {
			statements = t.codeTreeArray
			if statements {

				n = len(statements) 
				if n == 0 				{ if t.wsOnly { push(out, t.wsOnly) } }
				for i * n {
					statement = statements[i]
					unparseRec(statement)
					if statement.divider { push(out, statement.divider) }
					if statement.subTree { unparseRec(statement.subTree) }
				}

			} else {

				if t.ws1               		{ push(out, t.ws1) }
				if t.leftBracket     		{ push(out, t.leftBracket) }
				
				items = t.items
				if items {
					override = unparseItems and unparseItems(out, t, unparseRec)
					if override == nil {
						n = len(items)
						if n == 0 			{ if t.wsEmptyBracket { push(out, t.wsEmptyBracket) } }
						else 				{                  unparseRec(items[0]) }
						for i = 1, n - 1	{ push(out, ',') ; unparseRec(items[i]) }					
					}
				} else {
					if t.left               { unparseRec(t.left) }	
					
					if t.token              { push(out, t.token) }
					else if t.dataId != nil { push(out, unparseData(t)) }
					
					if t.right              { unparseRec(t.right) }
				}
				
				if t.rightBracket			{ push(out, t.rightBracket) }
				if t.ws2					{ push(out, t.ws2) }				
			}
		}
		unparseRec(tree)
	}		

	unparseStatements = nil
	unparseStatements = func out, codeTreeArray, unparseConstant, unparseItems {
		ln = len(codeTreeArray)
		for i * ln {
			codeTree = codeTreeArray[i]
			codeNodeToValue = unparseConstant == nil ? func node { node.number != nil ? node.number : (node.string != nil ? node.string : '???') } : unparseConstant
			unparseExpression(out, codeTree, codeNodeToValue, unparseItems)
			if codeTree.subTree {
				push(out, '-->')
				unparseStatements(out, codeTree.subTree, unparseConstant, unparseItems)
				if i != ln - 1 {
					push(out, '<--')
				}	
			} else if i != ln - 1 {
				push(out, ';')
			}
		}
	}

	api unparseCodeTree = func , codeTrees, unparseConstant, unparseItems {
		out = []
		unparseStatements(out, codeTrees, unparseConstant, unparseItems)
		return arrayConcatToString(out)
	}	



		
#####
		unparseTest = func treeAndResult, full {
			out = []
			unparseExpression(out, full ? treeAndResult.fullCodeTree : treeAndResult.codeTree)
			out
		}

	testCallbacks = defaultParseContext()
	testCallbacks.unaryOperators ['-'].callback = func a { -a } 
	testCallbacks.binaryOperators['' ].callback = func a, b { if a == 'fishFunc' { return b + 1} else { return a + b } } 
	testCallbacks.binaryOperators[','].callback = func a, b { {l = a, r = b} } 
	testCallbacks.binaryOperators['+'].callback = func a, b { a + b } 
	testCallbacks.binaryOperators['*'].callback = func a, b { a * b } 
	testCallbacks.binaryOperators['='].callback = func a, b { a * b } 
		

	testExecuteCallbacksR = nil
	testExecuteCallbacksR = func t, cb {
		data = nil
		items = t.items
		if items {
			data = []
			for k,v in items {
				push(data, testExecuteCallbacksR(v, cb)) 
			}
		} else if t.left {
			lData = testExecuteCallbacksR(t.left, cb)
			rData = testExecuteCallbacksR(t.right, cb)
			opcode = cb.binaryOperators[t.token]
			if not opcode { throw('no such opcode '..t.token..' '..serialize(t))}
			data = opcode.callback(lData, rData)
		} else if t.right {
			data = testExecuteCallbacksR(t.right, cb)
			tok = t.token
			if tok {
				opcode = cb.unaryOperators[tok]
				if not opcode { throw('no such opcode '..tok..' '..serialize(t))}
				data = opcode.callback(data)
			}
		} else {
			data = t.string
			if data == nil { data = t.number }	
			if data == nil { data = t.token }	
		}
		data
	}

	parseTest = func txt, cb {
		resetParserDataIdGenerator()
		it = createTokenIterator(parseToTokens(txt))
		result = nil
		codeTree = nil // parseExpressionR(it, 0, cb)
		fullCodeTree = parseStatements(it, cb)
		if len(fullCodeTree.codeTreeArray) > 0 {
			codeTree = fullCodeTree.codeTreeArray[0]
			result = testExecuteCallbacksR(codeTree, cb)
		}
		{ fullCodeTree = fullCodeTree, codeTree = codeTree, result = result}
	}


		unitTest('parser1', func { serialize(parseTest("1"  , testCallbacks).result)}, '1')

		unitTest('parser2', func { serialize(parseTest("1+2", testCallbacks).result)}, '3')

		_tmp = "/*lax*/(/*is*/ 1 /*nice*/)//"
		unitTest('parser3', func { arrayConcatToString(unparseTest( parseTest(_tmp, testCallbacks) ))}, _tmp)


		

		assert( parseTest("6+6+6", testCallbacks).result, '==', 6+6+6)

		code1 = " (  1   +    2     )//" ;
		spec1 = { ws1 = ' ', leftBracket = '(', token = '+', rightBracket = ')', ws2 = '//'
					left =  { ws1 = '  ',   number = 1, dataId = 1, ws2 = '   '}, 
					right = { ws1 = '    ', number = 2, dataId = 2, ws2 = '     '}
				}
		unitTest('parser4',  func { serialize(parseTest(code1, testCallbacks).codeTree) }, serialize(spec1))
		
		unitTest('parser5',  func { parseTest(" 4  +   5    *     6      ", testCallbacks).result }, 4+5*6)

		
		unitTest('parser6',  func { arrayConcatToString(unparseTest(  parseTest(" 4  +   5    *     6      ", testCallbacks)))},
			" 4  +   5    *     6      ")
		
		code2 = " 1  +   2    *     3//"
		unitTest('parser7', func { arrayConcatToString(unparseTest(parseTest(code2, testCallbacks) ))}, code2)


		code4 = "fishFunc 4"
		spec4 = { token = ''
					left =  { /*isSymbol = true,*/ token = 'fishFunc', ws2 = ' '}
					right = { items = [{number = 4, dataId = 1}], leftBracket = '', rightBracket = '', itemsId = 1}
				}
		unitTest('parser8', func { serialize(parseTest(code4, testCallbacks).codeTree) },  serialize(spec4))
		unitTest('parser9', func { arrayConcatToString(unparseTest(parseTest(code4, testCallbacks))) },  code4)


		code3 = "(10,20,30)"
		spec3 = {
					items = [{dataId = 1, number = 10}, {dataId = 2, number = 20}, {dataId = 3, number = 30}],
					leftBracket = '(', rightBracket = ')'
					itemsId = 1
				}
		unitTest('parser10', func { serialize(parseTest(code3, testCallbacks).codeTree) }, serialize(spec3) )
		unitTest('parser11', func { arrayConcatToString(unparseTest(parseTest(code3, testCallbacks))) }, code3 )


		code3 = "(a=10,20,30)"
		spec3 = {
					items = [{left = {token = 'a'}, token = '=', right = {dataId = 1, number = 10}}, {dataId = 2, number = 20}, {dataId = 3, number = 30}],
					leftBracket = '(', rightBracket = ')'
					itemsId = 1
				}
		unitTest('parser12', func { serialize(parseTest(code3, testCallbacks).codeTree) }, serialize(spec3) )
		unitTest('parser13', func { arrayConcatToString(unparseTest(parseTest(code3, testCallbacks))) }, code3 )


		code3 = "Sill = 100"
		spec3 = { left = {token = 'Sill', ws2 = ' '}, token = '=', right = {dataId = 1, ws1 = ' ', number = 100}}
		unitTest('parser13', func { serialize(parseTest(code3, testCallbacks).codeTree) }, serialize(spec3) )
		unitTest('parser14', func { arrayConcatToString(unparseTest(parseTest(code3, testCallbacks))) }, code3 )

		unitTest('parser15', func { arrayConcatToString(unparseTest(parseTest('/* sill */', testCallbacks),true)) }, '/* sill */' )

		unitTest('parser16', func { arrayConcatToString(unparseTest(parseTest('', testCallbacks),true)) }, '' )

		tmp = '10+1 --> b = 20  ; b = (b+6) <-- c=  30 '
		unitTest('parser17', func { arrayConcatToString(unparseTest(parseTest(tmp, testCallbacks),true)) }, tmp )
		unitTest('parser18', func { parseTest(tmp, testCallbacks).result }, 11 )


	/*


		code5 = "fishFunc 4 50"
		spec5 = { data = 55, isFunctor = true, 
					left = { data = 5, isFunctor = true, 
						left =  { data = 'fishFunc', ws2 = ' '}
						right = { data = 4, ws2 = ' '}
					}
					right = { data = 50 }
				}
		assert( serialize(parseTest(createTokenIterator(parseToTokens(code5)), testCallbacks)), '==', serialize(spec5) )

	*/
nil

#####


	// ---- Reactive Array ----
	// 
	// An array of reactive values, features:
	//   * (Optional) key support per item
	//   * Order is preserved when used as a associative array
	//   * Hooks for value insert/delete notifications
	//
	//   internally this has two implementations,
	//   as long as you don't specify any keys and only add/delete
	//   items at the end, it will use a simple array internally.
	//   the key-value implementation uses a linked
	//   list+hash for good scaling on random insertions
	//
	//   since this is the only containerobject, it should
	//   for instance work as a queue with 100000+ items
	//
	//   value is assumed to be a reactive value, and it actually uses
	//   the value-object to store a number of fields managing linked
	//   etc lists (this is both to avoid additional data structures
	//   and to enable easier debugging of which arrays an object is included in)

	// PROBLEM: using counter based id's for synchronisation
	//    if the last item is removed, and then one is added, they might get the same Id
	//    this might cause synchronisation problems... try anyway, for now, unique id's are slow
	//    to generate and will kill the simple implementation-case for arrays
	//    SOLUTION: reactive arrays come in 2 flavours: list and array, both support keys
	//              but lists always have unique keys, and synchronisation is always done by key.
	//              Going back to the example, if it is a list -no problem, if array one was replaced by another.

	// PROBLEM: Item order synchronisation
	//   If nextK is not found, the insertion cannot complete
	//   * if postponed (by the above abstraction), it might be that nextK is deleted, and insertion will never happen
	//   * if inserted anyway, order will be messed up in some cases (even if both next/prev are provided)
	//   * what if there's a second linklist sentinel?
    //
	//     o o o D B C A D   ( 'o o o' is current state, and other items are added, but we get notifications in order A B C D )
	//     o o o A
	//     o o o A B
	//
	//    use both next/prev for order, let above abstraction deal with the pain;
	//    - if an item is added/deleted/moved we'll have to go through the queued insertions and adjust next / prev id's
	//    SOLUTION: what if we support next, prev and sortPrio

	// PROBLEM: (FIXED!) Changing the array structure during iteration might cause errors
	//    Can be avoided by creating an iterator object that actually moves itself through the list
	//    (then "iterator.nextItem" need to be implemented as a loop, since it should skip other iterators)
	//    


	idCounter = 100
	api raUnhookAll = nil // fix forward declaration
	api raCreate = func uniqueID {
		ra = { ___class = 'reactiveArray', a = [] }
	//	ra.remove = func { raUnhookAll(ra) }
		if uniqueID { ra.id = uniqueID }
		ra
	}

	api raLen = func ra { if ra.kv == nil { return len(ra.a) } return ra.len }

	api raGet = func ra, k {
	    kv = ra.kv
		if kv { return kv[k] }
	    return ra.a[k]
	}

	api isReactiveArray = func x { x and isTable(x) and x.___class == 'reactiveArray' }


/*
	raFirstKey = func ra { kv = ra.kv ; if kv == nil { if len(ra.a) == 0 { return nil } return 0 } return ra.len > 0 and kv[0] or nil }

	raNextKey = func ra, k {
		kv = ra.kv
		if kv == nil {
			k = k + 1
			if k >= len(ra.a) { return nil }
			return k
		}
		item = kv[k]
		assert(item)
		nextItem = item[ra.tNext]
		if nextItem == ra.order { return nil }
		return nextItem[ra.tKey]
	}

	raIsKeyExplicit = func ra, k {
		if ra.kv == nil { return false }
		if raGet(ra, k)[ra.tHasKey] { return true }
		return false
	}


	raForEachKV_ = func ra, f {  // can be greatly optimized if rewritten without raFirstKey / raNextKey / raIsKeyExplicit / raGet
		key = raFirstKey(ra)
		while key {
			if raIsKeyExplicit(ra, key) {
				f(key, raGet(ra, key))
			} else {
				f(nil, raGet(ra, key))
			}
			key = raNextKey(ra)
		}
	}
*/

	api raForEachKV = func ra, f {  
		if ra.kv {
			tHasKey = ra.tHasKey
			tKey = ra.tKey
			llForEach(ra.order, func v { f(v[tHasKey] and v[tKey], v, v[tKey]) }, ra.tPrev, ra.tNext)
		} else {
			for i, v in ra.a { f(nil, v, i) }
		}
	}


	raConvertToUseKeys = func ra {
		assert(ra.kv == nil)
		if not ra.id { ra.id = 'I_'..idCounter ; idCounter = idCounter + 1 }
		kv      = {}
		tKey    = 'key_' ..ra.id       // not great, this was created so that reactive values can be linked to multiple reactive arrays
		tHasKey = 'hasKey_' ..ra.id
		tPrev   = 'prev_'..ra.id
		tNext   = 'next_'..ra.id
		order   = llCreate(tPrev, tNext)
		ra.kv = kv
		ra.tKey = tKey
		ra.tHasKey = tHasKey
		ra.tPrev = tPrev
		ra.tNext = tNext
		ra.order = order
		ra.len = len(ra.a)
		for i = 0, ra.len-1 {
			item = ra.a[i]
			assert(type(item), '==', 'table')
			llInsert(order, item, tNext, tPrev)
			kv[i] = item
			item[tKey] = i
		}
		ra.a = nil
	}

	queueNotificationForListener = func v, event {
		v.events.push(event)
		if not v.onQueue {
			v.onQueue = true
			later(func { v.f(v.events) ; v.events = [] ; v.onQueue = nil })
		}	
	}

	queueNotification = func ra, event {
		llForEach(ra.listeners, func v { queueNotificationForListener(v, event) }, 'prev', 'next')
		key = event[1]
		if ra.keyListeners and ra.keyListeners[key] { 
			llForEach(ra.keyListeners[key], func v { queueNotificationForListener(v, event) }, 'prev', 'next')
		}
	}

	api raIsKeyHidden = func ra, key {
		if ra.kv {
			v = ra.kv[key]
			if v == nil { throw('no such key '..key) }
			assert(v)
			tHasKey = ra.tHasKey
			return not v[tHasKey]
		}
		true
	}

	api raHookKey = func ra, key, f, skipInitSync {
		ra.keyListeners = ra.keyListeners or {}
		ra.keyListeners[key] = ra.keyListeners[key] or llCreate('prev', 'next')
		item = {events = [], f = f}
		llInsert(ra.keyListeners[key], item, 'next', 'prev')
		raHookKeyRemove = func {
			if item.prev {
				f([['removed', key]])
				llUnlink(item, 'prev', 'next')
			} else {
				print('warning raHookKeyRemove handle delete twice')
				throw('warning raHookKeyRemove handle delete twice')
			}
		}
		item.remove = raHookKeyRemove
		if not skipInitSync {
			val = raGet(ra, key)
			if val != nil {
				f([['inserted', key, val, raIsKeyHidden(ra, key) ]])
			}
		}   
 
		item
	}

	raUnhook = func item {
		if item.prev == nil {
			print('raUnhook WARNING already unhooked? '..item)
		} else {
			trace(spine, 'raUnhook '..item)			
		}
		ra = item.fullSyncOwner
		if ra {
			if ra.kv {
				tHasKey = ra.tHasKey
				tKey = ra.tKey
				llForEach(ra.order, func v { queueNotificationForListener(item, ['removed', v[tKey]]) }, ra.tNext, ra.tPrev)
			} else {
				ln = len(ra.a)
				for i * ln { queueNotificationForListener(item, ['removed', ln - 1 - i]) }
//				for i = len(ra.a) - 1, 0 { queueNotificationForListener(item, ['removed', i]) }
			}
			item.fullSyncOwner = nil
		}
		if item.prev != nil {
			llUnlink(item, 'prev', 'next')
		}
	}


	api raHook = func ra, f, skipFullSync {
	    assert(ra.___class == 'reactiveArray')  

		ra.listeners = ra.listeners or llCreate('prev', 'next')
		item = {events = [], f = f }
		llInsert(ra.listeners, item, 'next', 'prev')

		// callback for all current items
		if not skipFullSync {
			if ra.kv {
				tHasKey = ra.tHasKey
				tKey = ra.tKey
				llForEach(ra.order, func v { queueNotificationForListener(item, ['inserted', v[tKey], v, not v[tHasKey]]) }, ra.tPrev, ra.tNext)
			} else {
				for i, v in ra.a { queueNotificationForListener(item, ['inserted', i, v, true, i != 0 ? i - 1 : nil]) }
			}
			item.fullSyncOwner = ra
		}

		item.remove = func { raUnhook(item) }

		item
	}

	api raUnhookAll = func ra { llForEach(ra.listeners, raUnhook, 'prev', 'next') }

	api raForEach = func ra, f, skipFullSync {
		objs = {}
		return raHook(ra,  func events {
			for i,v in events {
				key = v[1]
				if v[0] == 'inserted' { 
					assert(objs[key], '==', nil)

					trace(spine, 'raForEach insert '..key)
					objs[key] = f(key, v[2], v[4], v[5], objs)

					assert(objs[key], '!=', nil)
				} else if v[0] == 'removed'  {
					assert(objs[key], '!=', nil)

					trace(spine, 'raForEach remove '..key)
					remove(objs[key])
					objs[key] = nil
				}
			}
		}, skipFullSync)					
	}

	findUnusedKey = func ra {
		kv = ra.kv 
		k = len(ra.a) 
		if kv {
			for i = k,k+100 {
				assert(i, '<', k+90)
				if kv[i] == nil {
					return i
				}
			}
		}
		return k
	}

	api raRemove = func ra, k {
		assert(ra.___class == 'reactiveArray')  
 		kv = ra.kv	
		if kv {
			item = kv[k]
			kv[k] = nil
			item[ra.tKey] = nil
			item[ra.tHasKey] = nil
			ra.len = ra.len - 1
			llUnlink(item, ra.tPrev, ra.tNext)
		} else {
			assert(k, '>=', 0)
			assert(k, '<', len(ra.a))
			pop(ra.a, k) 
		}
		queueNotification(ra, ['removed', k])
	}

	api raInsert = func ra, k, v, isKeyHidden, prevK, nextK {
	    assert(ra.___class == 'reactiveArray')  
	    assert( v.___class == 'reactiveValue')

	    kv = ra.kv
	    if kv == nil {
	    	if not isKeyHidden or isString(prevK) or (isNumber(prevK) and k != prevK+1)  or nextK or k != len(ra.a) {
				// print('convert to keys '..(not isKeyHidden)..(prevK or nextK)..(k != len(ra.a)) )
	    		raConvertToUseKeys(ra)
			    kv = ra.kv
	    	} else {
	    		push(ra.a, v)
				queueNotification(ra, ['inserted', k, v, true, k != 0 ? k - 1 : nil])
	    		return
	    	}
	    }

	    // key / value case
		assert(kv[k], '==', nil)

		if      prevK and kv[prevK] { llInsert(kv[prevK], v, ra.tPrev, ra.tNext) }
		else if nextK and kv[nextK] { llInsert(kv[nextK], v, ra.tNext, ra.tPrev) }
		else                        { llInsert(ra.order , v, ra.tNext, ra.tPrev) }

		kv[k] = v 
		v[ra.tKey] = k
		if not isKeyHidden {
			v[ra.tHasKey] = true
		}
		ra.len = ra.len + 1
		queueNotification(ra, ['inserted', k, v, isKeyHidden, prevK, nextK])
	}

	api raSet = func, ra, k, v { // untested
		oldV = raGet(ra, k)
		if oldV == v { return }
		isKeyHidden = false
		prevK = nil
		if oldV != nil {
			isKeyHidden = oldV[ra.tHasKey]
			prevK = (llGet(ra.order, oldV, ra.tPrev))[ra.tKey]
			raRemove(ra, k)
		}
		raInsert(ra, k, v, isKeyHidden, prevK)
	}

	api raPush = func ra, v {
		if ra.kv {
			return raInsert(ra, ra.len, v, true)
		}
		pos = len(ra.a)
		push(ra.a, v)
		queueNotification(ra, ['inserted', pos, v, true, pos != 0 ? pos - 1 : nil])
	}

	api raMap = func ra, f, f2, keepKeys {
		out = raCreate()
		handle = raHook(ra,  func events {
			for i,v in events {
				if      v[0] == 'inserted' { raInsert(out, v[1], f(v[1], v[2]), keepKeys and v[3] or true, v[4], v[5]) }
				else if v[0] == 'removed'  { f2(v[1]) ; raRemove(out, v[1]) }
			}
		})
		handle.raMapReturn = out
		handle
	}

	// createFunc should return handle with .rv
	api raMapObj = func ra, returnVal, createFunc, keepKeys {
		out = raCreate()
		items = {}
		handle = raHook(ra,  func events {
			for i,v in events {
				key = v[1]
				if v[0] == 'inserted' {
					item = createFunc(key, v[2])
					assert(isTable(item) and item.rv)
					items[key] = item
					raInsert(out, key, item.rv, keepKeys and v[3] or true, v[4], v[5])
				} else if v[0] == 'removed'  {
					raRemove(out, key)
					remove(items[key])
				}
			}
		})
		handle.raMapReturn = out
		if returnVal {
			set(returnVal, out)
		}
		handle
	}

	api raPop = func ra {  
		key = nil
		if ra.kv {
			item = llGet(ra.order, ra.tPrev)
			key = item[ra.tKey]
		} else {
			key = len(ra.a) - 1
			assert(key, '>=', 0)
		}
		raRemove(ra, key)
	}

	raToTextR = nil
	rvToTextR = func rv, out {
		v = get(rv)
		t = type(v)
		if      t == 'number'      { push(out, ''..v) }
		else if t == 'string'      { push(out, toJSON(v)) }
		else if t == 'table' and v.___class == 'reactiveArray'  { raToTextR(v, out) }
		else if t == 'table' and v.___class == "notReady"       { push(out, "???") } // use ??? for uninitialized
		else if t == 'nil'         { push(out, "0/*nil*/") }
		else                       { push(out, "0/*"..type.."*/") }
	}
	raToTextR = func ra, out {
		push(out, '[')
		first = true
		raForEachKV(ra, func k, rv {
			if first {
				first = false 
			} else {
				push(out, ', ')
			}
			if k != nil {
				push(out, ''..k..' = ')
			}
			rvToTextR(rv, out)
		})
		push(out, ']')
	}
	api raToText = func ra { out = [] ; raToTextR(ra, out) ; return join(out) }
	api rvToText = func rv { out = [] ; rvToTextR(rv, out) ; return join(out) }

	api reactiveToDs = nil
	api raToDs = func v, json {
		o = nil
		raForEachKV(v, func k, vv {
		    vv = reactiveToDs(vv, json)
		    if json {
			    if o == nil {
			      o = k == 0 and [] or {}
			    }
			    if type(o) == 'table' {
			      o[k] = vv
			    } else {
			      push(o, vv)
			    }		    
		    } else {
			    if o == nil {
			      o = []
			    }
		      tmp = vv
		      if k != nil {
		        tmp = {}
		        tmp[k] = vv
		      }
		      push(o, tmp)	    
		    }
//		    if o == nil {
//		      o = json and k != nil and {} or []
//		    }
//		    if json and k != nil {
//		      o[k] = vv
//		    } else {
//		      tmp = vv
//		      if k != nil {
//		        tmp = {}
//		        tmp[k] = vv
//		      }
//		      push(o, tmp)
//		    }
		})
		if o == nil { return [] }
		return o	
	}

	api reactiveToDs = func mv, json {
		v = get(mv)
		vt = type(v)
		if vt == 'string' or vt == 'number' /*or vt == 'bool'*/ {
			return v
		} else if vt == 'table' {
			if v.___class == 'reactiveArray' {
				return raToDs(v, json)
			} else {
				throw('reactiveToDs()  unknown type (1) ' .. vt)
			}
		}
		throw('reactiveToDs()  unknown type (2) ' .. vt)
	}

	api dsToReactive = nil
	api dsToReactive = func ds, json {
		mv = create()
		vt = type(ds)
		if vt == 'string' or vt == 'number' /*or vt == 'bool'*/ {
			set(mv,ds)
		} else if vt == 'array' {
			ra = raCreate()
			set(mv,ra)			
			if json {
				for i,v in ds {
					raPush(ra, dsToReactive(v))
				}
			} else {
				for i,v in ds {
					typev = type(v)
					if typev == 'table' {
						key = 'NOTFOUND'
						val = 'NOTFOUND'
						for kk,vv in v {
							key = kk
							val = vv
						}
						raInsert(ra, key, dsToReactive(val))
					} else {
						raPush(ra, dsToReactive(v))
					}
				}
			}
		} else if json and vt == 'table' {
			ra = raCreate()
			set(mv,ra)
			sortK = []
			for k, val in ds { push(sortK, k) }
			for _, k in sortInPlace(sortK) { val = ds[k]
				raInsert(ra, k, val)
			}	
		} else {
			throw('dsToReactive()  unknown type ' .. vt)
		}
		return mv
	}

#####

	testData = "1"
	unitTest('raArray1', func { serialize(reactiveToDs(dsToReactive(testData))) }, serialize(testData))

	testData = [{test = 1}]
	unitTest('raArray2', func { serialize(reactiveToDs(dsToReactive(testData))) }, serialize(testData))

	testData = [1,2,3]
	unitTest('raArray3', func { serialize(reactiveToDs(dsToReactive(testData))) }, serialize(testData))

	testData = [1,2,{a = 3}]
	unitTest('raArray4', func { serialize(reactiveToDs(dsToReactive(testData))) }, serialize(testData))

	testData = [{a = 1}, 2, 3]
	unitTest('raArray5', func { serialize(reactiveToDs(dsToReactive(testData))) }, serialize(testData))

	testData = [[]]
	unitTest('raArray6', func { serialize(reactiveToDs(dsToReactive(testData))) }, serialize(testData))

	testData = ['lax', 'sill', {a = ['ost', 'sik']}, 42]
	unitTest('raArray7', func { serialize(reactiveToDs(dsToReactive(testData))) }, serialize(testData))

	testData = [{a = [{b = [{c = 42 }] }] }]
	unitTest('raArray8', func { serialize(reactiveToDs(dsToReactive(testData))) }, serialize(testData))



	testA = dsToReactive([1,2])
	testB = raCreate()
	
	raHookHandle = raHook(get(testA), func events {
		for i,v in events {
			if      v[0] == 'inserted' { raInsert(testB, v[1], v[2], v[3], v[4], v[5]) }
			else if v[0] == 'removed'  { raRemove(testB, v[1]) }
		}
	})
	flushLater()
	unitTest('raArray SyncTest1', func { serialize(reactiveToDs(testA)) }, serialize(reactiveToDs(create(testB))))

	raInsert(get(testA),'testKey',create(1))
	raPush(get(testA),create('glass'))
	flushLater()
	unitTest('raArray SyncTest2', func { serialize(reactiveToDs(testA)) }, serialize(reactiveToDs(create(testB))))

	raRemove(get(testA),1)
	flushLater()
	unitTest('raArray SyncTest3', func { serialize(reactiveToDs(testA)) }, serialize(reactiveToDs(create(testB))))

	remove(raHookHandle)
	flushLater()	
	unitTest('raArray SyncTest4', func { serialize([]) }, serialize(reactiveToDs(create(testB))))

	raRemove(get(testA),0)
	raRemove(get(testA),'testKey')
	raRemove(get(testA),3) // 'glass'
	flushLater()
	unitTest('raArray SyncTest5', func { serialize(reactiveToDs(testA)) }, serialize(reactiveToDs(create(testB))))




  nil

#####
/*
ctxNode_get = func node, k {
	it = node
	while it {
		v = it.members[k]
		if v { return v }
		it = it.parent
	}
}

ctxNode_updateRec = nil
ctxNode_updateRec = func node, k, v {
//	if node.connectionHints[k] {
		if v == nil and node.parent { v = get(node.parent.connections[k]) }		
		if node.connections[k] {
			set(node.connections[k], v)		
		}
		llForEach(node.subnodes, func n {  // optimize: use llForEachFast?
			if n.members[k] == nil {
				ctxNode_updateRec(n, k, v)
			}
		})
//	}
}


api createNamespaceNode = func parent {
	node = { connections = {}, members = {}, parent = parent }
	hookctx = createHookContext()

	if parent {
		if not parent.subnodes { parent.subnodes = llCreate('prev','next') }
		llInsert(parent.subnodes, node, 'prev', 'next')	
	}

	node.set = func k, v {
		node.members[k] = v
		ctxNode_updateRec(node, k, v)
	}
	
	node.connect = func k, f {	// f is always called on connection
		rv = node.connections[k]
		if rv == nil {
			val = ctxNode_get(node, k)
			onZeroConnections = func { node.connections[k] = nil }
			rv = create(val, onZeroConnections)
			node.connections[k] = rv


		}
		return hook(hookctx, rv, func { f(get(rv)) }, true)
	}

	node.remove = func { remove(hookctx) ; llUnlink(node, 'prev', 'next') ; llForEach(node.subnodes, func n { remove(n) }, 'next', 'prev') }

	node
}


api connectNamespaceToArray = func ns, ra {
	raHook(ra, func events {
		for _, eventInfo in events {
			eventType = eventInfo[0]
			k = eventInfo[1]
			v = eventInfo[2] 
			hasKey = eventInfo[3] 
			if hasKey {
				if eventType == 'inserted' {
					ns.set(k, raGet(k))
				} else if eventType == 'removed' {
					ns.set(k, nil)
				}			
			}
		}
	})
}

*/
  nil


#####

api modifyTreeAPIForDataMatching = func tree {  // replaces tree.setGlobalCallbacks with tree.setGlobalDataMatchCallbacks

  globalDataMatches = {}
  hookAllDataCtx = createHookContext()
  hooksByNodeIs = {}
  nodeIdsToMatch = {}
  _matchRemove = func n { 
    item = nodeIdsToMatch[n.id]
    if item {
      item.removedMatch(n)
      item.nodes[n.id] = nil
      nodeIdsToMatch[n.id] = nil
    }
  }
  globalDataMatchCallbacks = func str, newMatch, removedMatch {
    if newMatch == nil and removedMatch == nil {
      assert(globalDataMatches[str])
      for id, node in globalDataMatches[str].nodes {
        _matchRemove(node)
        assert(hooksByNodeIs[id])
        unhook(hooksByNodeIs[id])    
        hooksByNodeIs[id] = nil    
      }
      globalDataMatches[str] = nil
      return
    }
    globalDataMatches[str] = {newMatch = newMatch, removedMatch = removedMatch, nodes = {} }
  }
  onCreateNode = func n {
    assert(hooksByNodeIs[n.id], '==', nil)  
    hooksByNodeIs[n.id] = hook(hookAllDataCtx, n.data, func { 
      _matchRemove(n)
      item = globalDataMatches[get(n.data)]
      if item {
        item.newMatch(n)
        item.nodes[n.id] = n
        nodeIdsToMatch[n.id] = item
      }
    } , true)
  }
  onDeleteNode = func n { 
    _matchRemove(n)
    assert(hooksByNodeIs[n.id])
    unhook(hooksByNodeIs[n.id])
    hooksByNodeIs[n.id] = nil 
  }
  tree.setGlobalCallbacks(onCreateNode, onDeleteNode)
  tree.setGlobalCallbacks = nil
  tree.setGlobalDataMatchCallbacks = globalDataMatchCallbacks
}










#####

// isDigit = func t { t>=48 and t<=57 }

api extentTreeWithReactiveAttributes = func tree {

//  define uiCheckbox
//    uiLayoutBox +horisontal, ${w h}
//      'check' uiButton ${* -w -h -text -image}, image = $image or skin.checkBoxImage, w = $h,  
//      'label' uiButton ${* -w -h -image}
//	  
//  uiCheckBox value = myToggleVar, text = "myToggleVar", alpha = 0.7
//  'skin'
//    checkBoxImage
	
//	header: "uiCheckBox"
//  attrib: ["value =", ["myToggleVar"], "text =", ["'myToggleVar'"], "alpha =", []
	
	elementInfo = { } // { elementClass = { create = func n {} } } 
	
				   // add support for functionlike quicklist of parameters? (basically a simple array of key names) 
				   // add support for support of specialized parsers per types? 
				   
	parseAttributes = nil

	globalAttributes = {}
	getCurrentAbstractionAttributes = func n {
		while n {
			n = tree.parent(n) 
			if n and n.elementClass == 'define' { return n.dataAttributes }
		}
		return globalAttributes
	}
	
	
	
	hookSync = func ctx, dst, src {
		hook(ctx, src, func { set(dst, get(src)) }, true)
		hook(ctx, dst, func { set(src, get(dst)) }, false)
	}
	
	saveFieldsOnDeInit = {
		+ id					// readonly
		+ data
		+ parentId
		+ sortPrio
		
		+ parent				// stapi system/private?  (remove?)
		+ tNext				 	// stapi system/private?
		+ tPrev				 	// stapi system/private?
		+ tSubnodes	 			// stapi system/private?
		+ setFromDiff			// stapi system/private?
		+ updateFromGetChanges	// stapi system/private?
		+ updateTreelocation	// stapi system/private?
		+ observers         	// stapi system/private?
		+ observingSubjects 	// stapi system/private?
				
		+ attributeHooks        // reactiveAttributes system/private?
		+ attributeTree         // reactiveAttributes system/private?
		+ attributeHooks        // reactiveAttributes system/private?
		+ dataHeader            // reactiveAttributes system/private?
		+ dataAttributes        // reactiveAttributes system/private?
	}
	
	elementStack = {}
	pushElementClass = func name, ec {
		if elementInfo[name] { 
			elementStack[name] = elementStack[name] or []
			push(elementStack[name], elementInfo[name])
		}
		elementInfo[name] = ec
	}
	popElementClass = func name {
		ec = elementInfo[name]
		assert(ec, '!=', nil)
		elementInfo[name] = elementStack[name] and pop(elementStack[name])
		ec
	}

//	whenEquals = func ctx, a, b, f, reverse {
//		ta = type(a)
//		tb = type(b)
//		
//	}
	
//	value = parseExp(stapi, node, 'parent.someContainer.someVar')
	
//	when( parseExp(stapi, node, 'parent.someContainer.someVar == true')
	
//	value = access(stapi, node, 'parent', func {
//			access(stapi, node, 'someContainer', func {
//		
//			})		
//		})
	
	setEnableRec = nil
	setEnableRec = func stapi, n, value {
		if n.isEnabled == nil {
			stapi.traverseSubNodes(func sn { setEnableRec(stapi, sn, value) } )
		} else if n.isEnabled != value  {
			n.isEnabled = value 
			stapi.traverseSubNodes(func sn { setEnableRec(stapi, sn, value) } )
		}
	}
	
	updateNodeFromData = func n {
		s = get(n.data)
		it = nil ; nameId = nil ; eClass = nil
		if n.isEnabled and substring(s,0,1) != '.' {
			it = createTokenIterator(parseToTokens(s))
			nameId = it.peek() == "'" and it.parseQuotedString()
			eClass = it.peek()
		}
		if n.elementClass and eClass != n.elementClass {
			if n.element { remove(n.element) ; n.element = nil } 
			else { print(n.elementClass .. "(no element object to delete)") }
			if n.reactiveElementHooks { unhook(n.reactiveElementHooks) }
//			for k, v in n {
//				if not saveFieldsOnDeInit[k] { n[k] = nil } // higher level implementations might not nil their members
//			}
		}
		if eClass != nil {
			it.proceed()
			n.dataHeader = it.getTokenRange(0,it.getTokenPos()) + it.proceed(true)
			res = tryCall(func { parseAttributes(n, it, getCurrentAbstractionAttributes(n)) })
			attrs = res.ret or {}
			if res.error {
				print("parseAttributes() Exception "..res.error)
			}
			attributeConfigurationChange = false
			if n.dataAttributes {
				// dataAttributes is the "interface", so we need to reuse the objects,
				// otherwise, attribute notifications will be lost.
				// so, here we do the splicing
				for key, val in n.dataAttributes {
					if attrs[key] {			// ATTRIBUTE : LINK TO NEW MODELOBJECT
						hookSync(n.attributeHooks, val, attrs[key])
						attrs[key] = nil
					} else {				// ATTRIBUTE : REMOVED
						set(n.dataAttributes[key], nil)
						n.dataAttributes[key] = nil
						attributeConfigurationChange = true
						// anyone need callback for removal?
					}
				}
			} else {					
				n.dataAttributes = {}
			}
			for key, val in attrs {			// ATTRIBUTE : CREATED
				n.dataAttributes[key] = create()
				hookSync(n.attributeHooks, n.dataAttributes[key], val)	
				attributeConfigurationChange = true
				// anyone need callback for creation?
			}
			if eClass != n.elementClass {
				attributeConfigurationChange = true
				
				prevBlockSubTreeExecution = n.blockSubTreeExecution
				if elementInfo[eClass]      { n.element = elementInfo[eClass].create(n)  }
				else if elementInfo.generic { n.element = elementInfo.generic.create(n) }
				else { print(eClass .. "(unknown class!) create fail") }
				if prevBlockSubTreeExecution != n.blockSubTreeExecution {
					// TODO notify subtree
				}
			}
			if attributeConfigurationChange and n.element and n.element.setupAttributes {
				n.element.setupAttributes()
//				trySetupAttrs = nil
//				trySetupAttrs = func {
//					errId = n.element.setupAttributes()
//					if errId {
//						dependency = tree.getNode(errId)
//						if dependency {
//							assert(get(dependency.stage), '>=', '04_elementCreated')
//							executeOnCondition(dependency.stage, func {
//								if get(dependency.stage) == '04_elementCreated' {
//									trySetupAttrs()
//								}
//							})
//						}
//					}
//				}
			}
		}
		n.elementClass = eClass
		n.nameId = nameId
	}

	escapeQuotesAndLinefeed = func s {
		return "'" .. findAndReplace(findAndReplace(s, "'", "\\'"),  '\n', '\\n') .. "'"
	}

	updateDataFromNode = func n {
		dataToks = parseToTokens(get(n.data))
		datastr = n.dataHeader
		deepIterateArrays(n.attributeTree, func leaf {
			if leaf.owned {
				d = get(leaf.data)
				if type(d) == 'number' {
					datastr = datastr .. leaf.preWhite .. toString(d) .. leaf.postWhite
				} else {
					assert(type(d), '==', 'string')
					datastr = datastr .. leaf.preWhite .. escapeQuotesAndLinefeed(d) .. leaf.postWhite					
				}
			} else {
				datastr = datastr .. arrayConcatToString(subarray(dataToks, leaf.tb, leaf.te))
			}
		})
//		aldeb(n.attributeTree)
//		alert(datastr)
		set(n.data, datastr) 
	}
	
	treeRelation = {+parent, +first, +last, +next, +prev}

	parseExp = nil
	parseExp = func stapi, n, it, instanceAttribs {
		last = nil
		out = []
		t = it.peek()
		if t == '$' {
			tb = it.getTokenPos()
			it.proceed()
			t = it.peek(); it.proceed()
			if not instanceAttribs[t] {				
				last = create(nil) // feels a bit silly to create nil objects, we could have a global mNil, but could be unsafe if it is set by mistake
	//			instanceAttribs[t] = last // should we add this attribute here as an "output"?
			} else {
				last = instanceAttribs[t] // direct reference here, should this rather be one way sync?
			}
			push(out, {data = last, text = '$' .. t, tb = tb, te = it.getTokenPos()})
		} else if t == "'" {
			preWhite = it.proceed(true)
			last = create(fromJSON('"'..substring(it.parseQuotedString(),1,-1)..'"')) // TODO: FIX CORRECT UNESCAPING
			push(out, {data = last, owned = true, preWhite = preWhite, postWhite = it.proceed(true)})
		} else if isDigit(charCodeAt(t,0)) {
			preWhite = it.proceed()
			last = create(toNumber(t))
			push(out, {data = last, owned = true, preWhite = preWhite, postWhite = it.proceed(true)})
		} else if treeRelation[t] {
			obj = nil											// need to hook relation?
			if t == 'parent' { obj = stapi.parent(n) }
			// TODO...
			last = create({type = 'nodeRef', id = obj.id})
			push(out, {data = last, owned = true, preWhite = preWhite, postWhite = it.proceed(true)})
		} else {
		
		}
		
		// post
//		while() {
//			t = it.peek()
//			if t == '(' { // assume function call
//				parseExp(stapi, n, it, instanceAttribs)
//			}
//		}
		
		out
	}
	

	findLastInDeepArray = nil
	findLastInDeepArray = func a {
		if type(a) == 'array' { last = getLast(a) ; return findLastInDeepArray(last) }
		a
	}
	
	parseAttributes = func n, it, instanceAttribs {
		r = {}
		if n.attributeHooks { unhook(n.attributeHooks) }
		n.attributeHooks = createHookContext()
		n.attributeTree = []
		while it.peek() {
			pos = it.getTokenPos()
			if it.peek() == '$' {
				it.proceed()     // parse  ${* -w -h -color}
				if it.peek() == '{' { it.proceed()
					keys = {}
					if it.peek() == '*' { it.proceed() //{
						for k, v in instanceAttribs {
							keys[k] = v
						}
						while it.peek() != '}' {
							if it.peek() == '-' { it.proceed()
								keys[it.peek()] = nil
								it.proceed()
							} else {
								throw('expected minus after *')
							}
						}
					} else {
						while it.peek() != '}' {
							k = it.peek()
							if instanceAttribs[k] {
								keys[k] = instanceAttribs[k]
							}
							it.proceed()
						}
					}
					for k,v in keys {
						r[k] = v
					}
				} else { throw('expected { after $') }
				push(n.attributeTree, {text = it.getTokenRange(pos, it.getTokenPos()), tb = pos, te = it.getTokenPos()})
			} else {
				key = it.peek(); it.proceed()
				if it.peek() == '=' {
					it.proceed()
					if it.peek() != nil {
						push(n.attributeTree, {attrName = key, tb = pos, te = it.getTokenPos()})
						exprTree = parseExp(n, it, instanceAttribs)
						r[key] = findLastInDeepArray(exprTree).data
						assert(r[key])
						push(n.attributeTree, exprTree)
					} else {
						n.attributeTree = []
						throw("Parse Error! expected expression after = but found nil")
					}
				} else {
					n.attributeTree = []
					throw("Parse Error! expected = but found "..it.peek())
				}
			}
			if it.peek() == nil or it.peek() == ',' {
				pos = it.getTokenPos()
				it.proceed()
				it.peek() // todo fix, bad design 
				push(n.attributeTree, {tb = pos, te = it.getTokenPos()})
		} else {
				throw("Parse Error! expected , but found "..it.peek())
			}
		}
		hookMultiple(	n.attributeHooks
						selectUsing(deepIterateArrays, n.attributeTree, func i { i.owned and i.data })
						0.25
						func { updateDataFromNode(n) ; updateQueued = false }
					)
		n.tmpParseOwned = nil
		r
	}
	
	hctx = createHookContext()
	_hooks = {}
	onCreateNode = func n {
		_hooks[n.id] = hook(hctx, n.data, func { updateNodeFromData(n) } , true)
	}
	onDeleteNode = func n {	
		assert(_hooks[n.id])
		unhook(_hooks[n.id])
	}
	tree.setGlobalCallbacks(onCreateNode, onDeleteNode)	
	
	tree.pushElementClass = pushElementClass
	tree.popElementClass = popElementClass
}

#####


magsqr = func a { o = 0 ; for i * len(a) { v = a[i] ; o = o + v * v } o }
/*
function magsqr(a)	{ var i,c=a.length,o=0; for(i=0;i<c;i++) o+=a[i]*a[i]; return o}


function mag(a)	{ return sqrt(magsqr(a))}

function normalize(v){ return vsmul(v,1/mag(v))}

function distance(a,b){ if(!a.splice && !b.splice) return abs(a-b); return mag(sub(a,b))}

var length=mag

function sum(ar)	{ var i,r=0,a=ar.splice?ar:arguments; for(i=0;i<a.length;i++) r+=a[i]; return r}

function product(ar){ var i,r=1,a=ar.splice?ar:arguments; for(i=0;i<a.length;i++) r*=a[i]; return r}

function mean(a)	{ return sum.apply(null,arguments)/(a.splice?a:arguments).length}

function geometricMean(a)	{ return pow(product.apply(null,arguments),1/(a.splice?a:arguments).length)}

function sort(a,b)	{ if(typeof a!='object') a=Array.prototype.slice.call(arguments, 0); if(typeof b!='function') b=function(i,j) { return i-j; }; return a.sort(b)}

function sortr(a,b)	{ var ob,bf; if(typeof a!='object') a=Array.prototype.slice.call(arguments, 0); if(typeof b!='function') bf=function(i,j) { return j-i; }; else { ob=b; bf=function(i,j) { return ob(j,i); };} return a.sort(bf)}

function median(a) { if (!arguments || arguments.length == 0) return undefined;	if(typeof a!='object') a=Array.prototype.slice.call(arguments, 0); var n=a.length; a=a.sort(function(i,j) { return i-j; });	return n%2==1 ? a[floor(n/2)] : (a[n/2-1]+a[n/2])/2}
*/

#####

	api wrapSetToModel = func hc, values, createFunc {
		model = {}
		interface = createFunc(values, func whatChanged, data {
			rv = model[whatChanged]
			if rv /*and compatible(rv)*/ { set(rv, data, model) }  // compatible is only needed if callback is called several times during init, and this should maybe be considered an error
			else { model[whatChanged] = data }
		})
		for name, fun in interface {
			t = substring(name, 0, 3)
			if t == 'set' {
				attr = toLower(substring(name, 3, 4)) .. substring(name, 4)
                ival = model[attr]
				if ival == nil { ival = values[attr] }
				if ival == nil { ival = interface['get'..substring(name, 3)] and interface['get'..substring(name, 3)]() }
				if ival == nil { throw('missing defaultvalue for '..attr) }
				mval = create(ival)
				model[attr] = mval
				hook(hc, mval, func { fun(get(mval), 'modelToApi') }, true)
			}
		}
		model
	}

#####

/*

UNUSED ?

api createUISystem = func bd, tree, uiRoot, wantDraw {

	uiHitTest = func pos, which {
		selectUsing(tree.traverseR, uiRoot, func n {
			e = n.element ; e and e.hitTest and e.hitTest(pos, which) and e 
		})
	}
	uiDraw = func {
		bd.fillColor('#000000')
		bd.fillAlpha(1)
		bd.fillRect(0,0,3000,3000)		
		tree.traverse2(uiRoot,	func n { if n.element and n.element.draw        { n.element.draw()        } },
								func n { if n.element and n.element.drawOverlay { n.element.drawOverlay() } })
	}
	uiUpdate  = func {
		flushTimers() if flushTimers
		; // TestIf9
	}
	inputSel = {}
	uiInputHandler = func id, pos, a3{
		if type(a3) == 'bool' {
			if a3 {
																assert(inputSel[id],'==',nil)
				sel = uiHitTest(pos, 'inputBegin')[0]
				if sel and sel.inputBegin { sel.inputBegin() }
				inputSel[id] = sel or true
			} else {
																assert(inputSel[id],'!=',nil)
				if sel and sel.inputEnd { sel.inputEnd() }
				inputSel[id] = nil
			}
		} else {												assert(inputSel[id],'!=',nil)
		
			if inputSel[id] and inputSel[id].inputDrag { inputSel[id].inputDrag(id, pos, a3) }
		}
	}
	return {
		update = uiUpdate
		inputHandler = uiInputHandler
		draw = uiDraw	
		wantDraw = wantDraw
	}
}
*/
#####


	api generateCodeConnectionGraph = func ttfResults, outOptional {
		tokenToWriteList = {}
		tokenToReadList = {}
		tokenUseCount = {}
		nodes = {}		
		for ttfId, res in ttfResults {
			m = res.meta

			for k,v in m.connections or {} {
				name = v.name
				if v.write {
					// this is really annoying, if name is toString/constructor/hasOwnProperty etc, code fails miserably! and the fix is quite strange
//					if tokenToWriteList[name] == nil { tokenToWriteList[name] = [] }

					if type(tokenToWriteList[name]) != 'array' { tokenToWriteList[name] = [] }
					push(tokenToWriteList[name], ttfId)
				} else {
					if tokenUseCount[name] != 'array' { tokenUseCount[name] = 0 }
					tokenUseCount[name] = 1 + tokenUseCount[name]
//					if tokenToReadList[name] == nil { tokenToReadList[name] = [] }
					if type(tokenToReadList[name]) != 'array' { tokenToReadList[name] = [] }
					push(tokenToReadList[name], ttfId)
				}
			}
			nodes[ttfId] = {
				dependencies = {}
				dependsOnMe = {}
				listOfTokensByImportance = []
				dnativeCode = res.dnative or ''
				dscriptCode = res.dscript or ''
				codeSize = res.dscript and len(res.dscript) or -1
				orderId = res.orderId
			}
		}		


		for ttfId, res in ttfResults {
			m = res.meta
			for k,v in m.connections or {} {
				if v.write {
					for _,ttfId2 in tokenToReadList[v.name] or {} {
						nodes[ttfId2].dependsOnMe[v.name] = ttfId
					}
					push(nodes[ttfId].listOfTokensByImportance, v.name)
				} else {
					for _,ttfId2 in tokenToWriteList[v.name] or {} {
						nodes[ttfId].dependencies[v.name] = ttfId2
					}
				}
			}
			sortInPlace(nodes[ttfId].listOfTokensByImportance, func a,b { tokenUseCount[a] > tokenUseCount[b] ? 1 : -1 } )
		}		

		if outOptional {
			outOptional.globalToListOfWriters = tokenToWriteList
			outOptional.globalToListOfReaders = tokenToReadList
		}

		nodes
	}

#####	

	api getCodeConnectionGraphDependencies = func nodes, ttfId {
		out = {}
		cyclicCheck = {}
		ccgd_recurse = nil
		ccgd_recurse = func idDependent {
			if cyclicCheck[idDependent] == nil {
				cyclicCheck[idDependent] = true
				if nodes[idDependent] == nil { throw('getCodeConnectionGraphDependencies error '..idDependent) }
				for name, id in nodes[idDependent].dependencies {
					out[id] = nodes[id]
					ccgd_recurse(id)
				}		
			}
		}
		ccgd_recurse(ttfId)
		out
	}



#####	
	kEncryptionWriteKey =  nil //"SymmetricWriteKey_ergsef4ud3d"
	kEncryptionReturnKey = nil //"SymmetricReturnKey_ergsef4ud3d"
	kEncryptionBits = 128

	api setServerJobEncryption = func writeKey, returnKey, bits {
		kEncryptionWriteKey = writeKey
		kEncryptionReturnKey = returnKey 
		kEncryptionBits = bits or 128
	}

	api serverJob = func options, jobSpec, result {
		serverAccessDir = options.serverAccessDir
		httpData = { }
		jsonJobs = toJSON(jobSpec)
		if kEncryptionReturnKey {
			httpData.jobs = AesEncrypt(jsonJobs, kEncryptionWriteKey, kEncryptionBits)
		} else {
			httpData.plainJobs = jsonJobs
		}

		return http(	serverAccessDir .. 'server_job.php',
						{ sendData = httpData },
						func err, txt {

			if not err and substring(txt,0,8) == 'success:' {
				returnText = substring(txt,8)
				if kEncryptionReturnKey {
					returnText = AesDecrypt(returnText, kEncryptionReturnKey, kEncryptionBits)
				}
				ret = tryCall(func { fromJSON( returnText ) } ).ret

//				alert(encryptedJobs .. "\n\n" .. txt .. "\n\ndec:" .. returnText .. "\n\n" .. toJSON(ret or {}))

				if ret {
					result(nil, ret)
				} else {
					result("serverJob() Error receiving result: " .. txt .. "\n\n" .. returnText, "")
				}
			} else {
				if err {
					result("serverJob() Error sending server job: " .. err, "")
				} else {
					result("serverJob() Error executing server job: " .. ' '.. txt .. "\n\n" .. returnText, "")				
				}
			}

		}) 
	}


#####	

	api httpRaw = func url, options, result {  // result = func error, base64string {}
		serverJob({serverAccessDir = ''}, [{cmd = 'get', bin=true, relPath=url}], func err, ret {
			if err {
				result("httpRaw Error "..url..' '..err)
			} else {
				ret = ret[0]
				if substring(ret, 0, 8) != 'success:' {
					result("httpRaw Error "..url..' '..ret)
				} else {
					result(nil, substring(ret, 8))					
				}
			}
		} )
	}

#####	

	// push data to server using multiple http get with encrypted data passed as querystring

	remoteServerJob = func url, jobSpec, maxSize, result {
		maxSize = maxSize ?: 1000
		destPath = 'tmp/' .. findAndReplace(createGlobalId(), '_', 'A') .. '__'
		jsonJobs = toJSON(jobSpec)
		totalLen = len(jsonJobs)

		numParts = floor(totalLen / maxSize) + 1
		for i * numParts {

			storePartSpec = [{
					type = 'file'
					sourceData = substring(jsonJobs, i*maxSize, min(totalLen, (i+1)*maxSize))
					targetRelDir = destPath .. i .. '__' .. numParts
				}]

			serverJob({}, storePartSpec, func err {
					if err { result(err) }
				})
		}
	}

#####	

	api buildAndDeploy = func buildSteps, serverAccessDir, sourceRelDir, destRelDir, result {
		depSpec = []
		waiting = 1
		com = createComposite()
		deployIfReady = func {
			waiting = waiting - 1
			if waiting == 0 {
				com.add(serverJob({serverAccessDir = serverAccessDir}, depSpec, result))
			}
		}
		for i,step in buildSteps {
			item = {}
			completeItem = func data {
				if data {
					for i,trans in step.transforms or {} { data = findAndReplace(data, trans[0], trans[1]) }
					item.data = data
				}
				deployIfReady()
			}
			waiting = waiting + 1
			typeIsFile = step.type == 'file'
			if step.type == 'mkdir' {
				item.cmd = 'mkdir'
				item.relPath = destRelDir .. (step.targetRelDir or '')
				completeItem()
			} else if typeIsFile or step.type == 'image' {
				data = nil
				item.cmd = 'set'
				if not (step.targetRelDir or step.sourceRelDir) {
					remove(com)
					result('buildAndDeploy() Missing targetRelDir or sourceRelDir' , '')
				}
				item.relPath = destRelDir .. (step.targetRelDir or step.sourceRelDir)
				if step.sourceData {
					completeItem(step.sourceData)
				} else if step.sourceRelDir {
					(step.bin ? httpRaw : (typeIsFile ? http : getImage)) (serverAccessDir .. sourceRelDir .. step.sourceRelDir, nil, func err, retData {
						if err {
							remove(com)
							result('buildAndDeploy() Error could not get file '..err, '')
						} else {
							if typeIsFile {
								item.bin = true if step.bin
								completeItem(retData)
							} else {
								item.bin = true
								completeItem(imageToBase64(retData._im))
							}
						}
					})
				} else {
					remove(com)
					result('buildAndDeploy Error, file missing sourceData or sourceRelDir', '')			
				}
			} else {
				remove(com)
				result('buildAndDeploy Error: no such build step type:' .. (step.type or 'nil') , '')
			}
			push(depSpec, item)			
		}
		deployIfReady()
		com
	}


#####	

	api sortedForEach = func tab, lesscmp, f {
		order = []
		if type(lesscmp) == 'func' {
			for k,v in tab { push(order, k) }
			sortInPlace(order, func a, b { lesscmp(tab[a], tab[b]) ? 1 : -1 })
			for i * len(order) {
				k = order[i]
				v = tab[k]
				f(k,v)
			}			
		} else {
			for k,v in tab { push(order, {k = k, cmp = v[lesscmp] }) }
			sortInPlace(order, func a, b { a.cmp < b.cmp ? 1 : -1 })
			for i * len(order) {
				k = order[i].k
				v = tab[k]
				f(k,v)
			}			
		}
	} 


#####	

api resizeWithInit = func a, n, initVal {  // initVal only works for passed-by-value (tables / arrays will not be copied)
	oldN = len(a)
	resize(a, n)
	for i = oldN, n - 1 {
		a[i] = initVal
	} 
}

#####	

api createArray = func n, init { o = [] ; resizeWithInit(o, n, init) if init != nil ; o }

#####	


api matrixInverse = func m {
	if len(m) == 2 and len(m[0]) == 2 {
		d = m[0][0] * m[1][1] - m[0][1] * m[1][0]
		if d == 0 { return }
		d = 1/d
		return [[d * m[1][1], -d * m[0][1]], [-d * m[1][0], d * m[0][0]]]

	} else if len(m) == 3 and len(m[0]) == 3 {
		d = m[0][0] * (m[1][1]*m[2][2] - m[2][1]*m[1][2]) -
		    m[0][1] * (m[1][0]*m[2][2] - m[1][2]*m[2][0]) +
		    m[0][2] * (m[1][0]*m[2][1] - m[1][1]*m[2][0])
		if d == 0 { return }
		d = 1/d
		return [[ d*(m[1][1]*m[2][2] - m[2][1]*m[1][2]),-d*(m[1][0]*m[2][2] - m[1][2]*m[2][0]), d*(m[1][0]*m[2][1] - m[2][0]*m[1][1])],
				[-d*(m[0][1]*m[2][2] - m[0][2]*m[2][1]), d*(m[0][0]*m[2][2] - m[0][2]*m[2][0]),-d*(m[0][0]*m[2][1] - m[2][0]*m[0][1])],
				[ d*(m[0][1]*m[1][2] - m[0][2]*m[1][1]),-d*(m[0][0]*m[1][2] - m[1][0]*m[0][2]), d*(m[0][0]*m[1][1] - m[1][0]*m[0][1])]] 	
	}
	alert('sorry only 2x2 and 3x3 matrices')
}

#####

api matrixIsIdentity = func m {
	for i * len(m) {
		for j * len(m[i]) {
			if j==i and m[i][j] != 1 or m[i][j] != 0 {
				return false
			}
		}
	}
	return true
}
#####	

api matrixMul = func a, b {
	lenB = len(b)
	rows = len(b[0])
	cols = len(a)
	o = createArray(cols)
	for c * cols {
		ac = a[c]
		newItem = createArray(rows, 0)
		for r * rows {
			for i * lenB {
				newItem[r] = newItem[r] + ac[i] * b[i][r]
			}
		}
		o[c] = newItem
	}
	return o
}
#####	

matrixCopy = deepcopy // only needed if we introduce types


/*  no var args support
diag = func {   
	c=arguments.length, o=ca(c)
	for(i=0;i<c;i++) {
		o[i]=ca(c)
		for(j=0;j<c;j++)
			o[i][j]=j!=i?0:arguments[i]
	}
	return o
}
*/



/*
eulerToMatrix = func m {
	var x=m[0],y=m[1],z=m[2]
	m=diag(1,1,1)
	if(x) m=mmul(m,[[1,0,0],[0,cos(x),-sin(x)],[0,sin(x),cos(x)]])
	if(y) m=mmul(m,[[cos(y),0,sin(y)],[0,1,0],[-sin(y),0,cos(y)]])
	if(z) m=mmul(m,[[cos(z),-sin(z),0],[sin(z),cos(z),0],[0,0,1]])
	return m
}

matrixToEuler = func m {
	var c,a=ca(3)
	a[1]=atan2(m[0][2], sqrt(m[0][0]*m[0][0]+m[0][1]*m[0][1]))
	c=cos(a[1])
	if (c > 0.000001 || c < -0.000001) {
		c = 1.0 / c
		a[0]=atan2(-m[1][2]*c, m[2][2]*c)
		a[2]=atan2(-m[0][1]*c, m[0][0]*c)
	} else {
		a[0]=0
		a[2]=atan2(m[1][0],m[1][1])
	}

	return a
}

matrixFlatten = func m { var i,o=m[0]; for(i=1;i<m.length;i++) o=o.concat(m[i]); return o}


matrixFromFlat = func m, w { var o=ca(m.length/w); for(i=0;i<o.length;i++) o[i]=m.slice(i*w,(i+1)*w); return o}
*/

#####	

	api currentProjectHttpDependencies = { }



	// same as http / getImage, but adds the resource as a project dependency

#####	api httpResource     = func url, options, f { currentProjectHttpDependencies[url] = true ; http    (url, options, f) }
#####	api getImageResource = func url, options, f { currentProjectHttpDependencies[url] = true ; getImage(url, options, f) }

/*

document.getElementById('graph').toDataURL(); 

image -> canvas -> dataurl -> base64 -> serverJob
*/

#####	

	api buildAndDeployCurrentProject = func serverAccessDir, sourceRelDir, destRelDir, projectTitle {
		//options = options ?: {}
		conns = {}
		completeGraph = generateCodeConnectionGraph(globalMeta, conns)		

		graph = {}
		orderMain = completeGraph['main'].orderId
		for id, node in completeGraph {
			if node.orderId >= orderMain {
				graph[id] = node
				extend(graph, getCodeConnectionGraphDependencies(completeGraph, id))
			}
		}

		isGlobalUsedByCurrentProject = func name { conns.globalToListOfWriters[name] and graph[conns.globalToListOfWriters[name][0]] and true or false }
		stripGL      = not isGlobalUsedByCurrentProject('createGuiContextGL')
		stripAudio   = not isGlobalUsedByCurrentProject('initRawSoundOutStream')
		stripCrypt   = not (isGlobalUsedByCurrentProject('AesEncrypt') or isGlobalUsedByCurrentProject('AesDecrypt'))
		stripDScript = not (isGlobalUsedByCurrentProject('textToFunc') or isGlobalUsedByCurrentProject('createDScript'))
		stripThree   = not isGlobalUsedByCurrentProject('getThreeJs')

		compiled = ['''
// Compiled to js using the Dim World Environment (ALPHA Version)
// (c) Martin 'teadrinker' Eklund, 2012 - 2025
// https://github.com/teadrinker/dim-world

dw_g_app_main = function() {''']

		runtime = nil
		parser = nil

		buildRelease = true
		if buildRelease {
			runtime = createRuntime('r_')
			runtime.registerGlobals(createIoLib(runtime.prefix).data)
			parser = createDScript(runtime, true)

			push(compiled, '\n\n')
			push(compiled, parser.generateCodeForInternalLib())
			push(compiled, '\n;\n')
		}

		sortedForEach(graph, func a,b { a.orderId > b.orderId }, func k, v {
			dnativeCode = nil
			if buildRelease {
				//res = parser.parse(v.dscriptCode)
				res = runtime.getGlobal('textToFunc')(v.dscriptCode)
				if res.error { alert(res.error) }
				else if k != 'main' { res.func() } // this is silly, we have to execute the code to register the js globals
				dnativeCode = res.dnative
			} else {
				dnativeCode = v.dnativeCode
			}
			if dnativeCode {
				push(compiled, '\n\n\n\n\n// '+k+' ('+v.orderId+')\n\n')
				push(compiled, dnativeCode)
				push(compiled, '();')
			}
		})
		push(compiled, '\n\n}')
		compiled = arrayConcatToString(compiled)

		remove(runtime)

		spec = [
			{type = 'mkdir', targetRelDir = '' }
			{type = 'file', sourceRelDir = 'index.html', transforms = [['<!-- app main script here -->', '<script src="dw_app_main.js"></script>']]} 
			{type = 'file', sourceRelDir = 'dw_runtime.js'}
		//	{type = 'file', sourceRelDir = 'dw_io_simple.js'} // moved to dw_runtime.js
		//	{type = 'file', sourceRelDir = 'dw_boot.js'}      // moved to dw_runtime.js
			{type = 'file', sourceData = compiled, targetRelDir = 'dw_app_main.js'}
		]

		if buildRelease {
			push(spec[1].transforms, ["dw_g_boot('dwds_')", "dw_g_boot('"..runtime.prefix.."')"])	
			push(spec[1].transforms, ["dwds_html_root", runtime.prefix.."html_root"])	
		}

		// always strip basic tests
		push(spec[1].transforms, ['<script src="dw_dscript_tests.js"></script>', ''])

		if stripDScript {
			//alert('strip')
			push(spec[1].transforms, ['<script src="dw_dscript.js"></script>', ''])
		} else {
			//alert('nostrip '..isGlobalUsedByCurrentProject('textToFunc')..'  '..toStr(isGlobalUsedByCurrentProject('createDScript')))
			push(spec, {type = 'file', sourceRelDir = 'dw_dscript.js'})	
		}

		if stripCrypt {
			push(spec[1].transforms, ['<script src="aes.js"></script>', ''])
		} else {
			push(spec, {type = 'file', sourceRelDir = 'aes.js'})	
		}

		if stripGL {
			push(spec[1].transforms, ['<script src="webgl-utils.js"></script>', ''])
		} else {
			push(spec, {type = 'file', sourceRelDir = 'webgl-utils.js'})	
		}

		if stripAudio {
			push(spec[1].transforms, ['<script src="XAudioJS/swfobject.js"></script>',    ''])
			push(spec[1].transforms, ['<script src="XAudioJS/resampler.js"></script>',    ''])
			push(spec[1].transforms, ['<script src="XAudioJS/XAudioServer.js"></script>', ''])		
		} else {
			push(spec, {type = 'mkdir', targetRelDir = '/XAudioJS' })
			push(spec, {type = 'file', sourceRelDir = 'XAudioJS/swfobject.js'})
			push(spec, {type = 'file', sourceRelDir = 'XAudioJS/resampler.js'})
			push(spec, {type = 'file', sourceRelDir = 'XAudioJS/XAudioServer.js'})
		}

		if stripThree {
			push(spec[1].transforms, ['<script src="three/three.js"></script>', ''])
		} else {
			push(spec, {type = 'mkdir', targetRelDir = '/three' })
			push(spec, {type = 'file', sourceRelDir = 'three/three.js'})	
		}

		if projectTitle {
			push(spec[1].transforms, ['<title>Dim World Boot</title>', '<title>' .. projectTitle .. '</title>'])		
		}

		root = {}
		for url, _ in currentProjectHttpDependencies {
			urlParts = split(url, '/')
			tmp = root
			for i * len(urlParts) - 1 {
				dirName = urlParts[i]
				tmp.dirs = tmp.dirs or {}
				tmp.dirs[dirName] = tmp.dirs[dirName] or {}
				tmp = tmp.dirs[dirName]
			}
			tmp.files = tmp.files or {}
			tmp.files[getLast(urlParts)] = true
		}

		parseDepRec = nil
		parseDepRec = func curPath, item {
			curPath = curPath..'/' if curPath != ''
			for dir, subItem in (item.dirs or {}) {
				relDir = curPath..dir
				push(spec, {type = 'mkdir', targetRelDir = relDir })
				parseDepRec(relDir, subItem)
			}
			for file, _ in item.files {
	//			itemSpec = {type = ext == '.jpg' or ext == '.png' ? 'image' : 'file', sourceRelDir = curPath..file } only works for png (jpg are converted to pngs)
				itemSpec = {type = 'file', sourceRelDir = curPath..file }
				ext = toLower(substring(file, len(file) - 4))
				itemSpec.bin = true if ext == '.jpg' or ext == '.png'
				push(spec, itemSpec)
			}
		}
		parseDepRec('', root)


		buildAndDeploy(spec, serverAccessDir, sourceRelDir, destRelDir, func err, res {
				if err {
					throw('buildAndDeployCurrentProject() Error'..err)
				} else {
					aldeb('deploy success!  ' .. serialize({stripDScript=stripDScript, stripCrypt=stripCrypt, stripGL=stripGL, stripAudio=stripAudio}) .. '\n' .. res)
					setURLRelative(destRelDir)
				}
			})
	}


/*

	// test
	if getGlobal('textToFunc') {	
//		alert('d')
		buildAndDeployCurrentProject('','','_tmp/')
	}


	buildAndDeploy([
						{type = 'mkdir' }
						{type = 'file', sourceRelDir = 'aes.js' }
						{type = 'file', sourceRelDir = 'index.html', transforms = [['<script src="dw_dscript.js"></script>', '']]}
						{type = 'file', targetRelDir = 'Lax.txt', sourceData = 'Hello there my Lax!' }
					], '', '', 'tmpdir/',
					func err, res {
						if err {
							throw('buildAndDeployCurrentProject() Error'..err)
						} else {
							aldeb('test success!  ' .. res)
						}
					})
*/


#####	

/*

var g_svg=[]
var g_svgfe=0
var g_svgfc="#000000"
var g_svgfa=1
var g_svgse=1
var g_svgsc="#000000"
var g_svgsa=1

	svgClearInner	: function(c,a)			{ g_svg = ["<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\"?>\n" +
														"<svg xmlns:svg=\"http:\/\/www.w3.org\/2000\/svg\" xmlns=\"http:\/\/www.w3.org\/2000\/svg\" xmlns:xlink=\"http:\/\/www.w3.org\/1999\/xlink\" version=\"1.0\" " +
														"width=\"" +drawWidth+ "\" height=\"" +drawHeight+ "\">\n<g>\n"]; }

var svgImpl = {	
	clear		: function(c,a)			{ svgClearInner()
										  var tmp=g_svgfc, tmpa=g_svgfa; g_svgfc=c; g_svgfa=a;
										  drawFillRect(0,0,drawWidth,drawHeight);
										  g_svgfc=tmp; g_svgfa=tmpa
										},
	beginPath		: function()			{ g_svg.push( "<path d=\"" ) },
	moveTo		: function(x,y)			{ g_svg.push( "M "+x+","+y+" ") },
	lineTo		: function(x,y)			{ g_svg.push( "L "+x+","+y+" ") },
	endPath		: function()			{ g_svg.push( "\" style=\"" +(g_svgse?"stroke:"+g_svgsc+";":"none") + ((g_svgse && g_svgsa!=1)?"stroke-opacity:"+g_svgfa+";":"")+
													  "fill:" + (g_svgfe?g_svgfc+";":"none")   + ((g_svgfe && g_svgfa!=1)?"fill-opacity:"+g_svgfa+";":"")+  "\" \/>\n" )},
	fillRect	: function(x,y,w,h)		{ g_svg.push( "<rect x=\"" +x+ "\" y=\"" +y+ "\" width=\"" +w+ "\" height=\"" +h+ "\" style=\"fill:" +g_svgfc+(g_svgfa!=1?";fill-opacity:"+g_svgfa:"")+ "\"\/>\n")},
	fillEnable	: function(b)			{ g_svgfe=b},
	fillColor	: function(c)			{ g_svgfc=c},
	fillAlpha	: function(a)			{ g_svgfa=a},
	strokeEnable: function(b)			{ g_svgse=b},
	strokeColor	: function(c)			{ g_svgsc=c},
	strokeAlpha	: function(a)			{ g_svgsa=a},
	strokeWidth	: function(w)			{ }, // todo
	transformPush	: function(a,b,c,d,e,f)		{ g_svg.push( "<g transform=\"matrix("+a+","+b+","+c+","+d+","+e+","+f)\">\n" },
	transformPop	: function()		{ g_svg.push( "<\/g>\n" },
	circle	: function(x,y,r)		{ g_svg.push( "<circle cx=\"" +x+ "\" cy=\"" +y+ "\" r=\"" +r+ "\"/>\n" },
	image		: function(im,x,y,w,h)	{ g_svg.push( "<image xlink:href=\"" +im.src+ "\" x=\"" +x+ "\" y=\"" +y+ (w==undefined?"":"\" width=\"" +w+ "\" height=\"" +h) + "\"/>\n" )},
	flushSVG	: function ()			{ g_svg.push( "<\/g>\n<\/svg>\n" ) 
											var tmp = g_svg.join("")
											svgClearInner()
											return tmp
										}
}				  

*/

	api createSVGRenderer = func {
		throw('createSVGRenderer no impl yet')
	}

#####	

	generateCodeConnectionVisualization = func graph { 
		// dependency tree, libraries as layers, application as centered mindmap on top
		// classification:        library / app ( / fatal error)       colors
		// selection (multiple):  highlighted and framed
		// enabled/disabled:      does appMain depend on codeblob? maybe more complex than that!
		// dnative / dscript / reactive
		// size (linecount)
		// info (list of function names sorted by prevalence)

		// additional classification:   math / io / tree

		// option: only show needed dependencies
		// option: hide libs

	}

#####	

api deepequals = nil
api deepequals = func a, b {

	ta = type(a)
	tb = type(b)
	if ta != tb {
		return false
	} else if ta == 'array' {
		if len(a) != len(b) {
			return false
		} 
		i = 0 ; leng = len(a) ; while i < leng { i = i + 1
			if not deepequals(a[i], b[i]) {
				return false
			}
		}
	} else if ta == 'table' { 
		if forK(a, func k {
			if not deepequals(a[k], b[k]) {
				return 'break'
			}
		}) != nil { return false }

		if forK(b, func k {
			if not deepequals(b[k], a[k]) { // could be improved...
				return 'break'
			}
		}) != nil { return false }


	} else {              // if ta == 'number' or ta == 'string' 
		return a == b
	}

	true
}

//  check https://github.com/stevedonovan/Penlight/blob/master/lua/pl/tablex.lua

//	for p in a {
//	if type(b[p]) == 'nil' {
//	return false
//	}
//	}
//	for p in a {
//	if a[p] {
//	t = typ(a[p])
//	if t == 'array' or t == 'table' { if not deepequals(a[p],b[p]) { return false; } }
//	//		else if case 'function': if(typeof(b[p])=='' || (p != 'equals' && a[p].toString() != b[p].toString())) return false; break
//	else if a[p] != b[p] { return false }
//	}
//	} else {
//	if b[p] {
//	return false
//	}
//	}
//	}
//	for p in b {
//		if(typeof(a[p])=='undefined') {
//			return false
//			}
//		}
//	return true



#####

	unitTest("deepequals1", func { deepequals({a=22},{a=22}) }, true)
	unitTest("deepequals2", func { deepequals({a=22,b=nil},{a=22}) }, true)
	unitTest("deepequals3", func { deepequals(3,1) }, false)
	unitTest("deepequals4", func { deepequals("t",1) }, false)
	unitTest("deepequals5", func { deepequals("t","t") }, true)
	unitTest("deepequals6", func { deepequals(99,99) }, true)
	unitTest("deepequals7", func { deepequals([1,2,3,{a=[]}],[1,2,3,{a=[]}]) }, true)
	unitTest("deepequals8", func { deepequals([1,2,3.001,{a=[]}],[1,2,3,{a=[]}]) }, false)
	unitTest("deepequals9", func { deepequals({a=1},{a=1,b=1}) }, false)
	unitTest("deepequals10", func { deepequals([1,2,3,{a=[],b=1}],[1,2,3,{a=[]}]) }, false)



#####

  api keysAsArray = func t { o = [] ; for k,_ in t { push(o, k) } ; o }

#####



	api dbSetUsingDiff = func db, key, newValue {
		diffForKey = diffRec(db.get(key), newValue)
		if diffForKey != nil {
			diff = {}
			diff[key] = diffForKey
			db.applyDiff(diff)
		}
	}

	api dbSetEntireUsingDiff = func db, newDBVersion {
		baseDB = {}
		db.enumKeys(func key {    
			baseDB[key] = db.get(key)  // this extra overhead is to enable realtime-joined databases
		})
		diff = diffRec(baseDB, newDBVersion)
		if diff != nil {
			db.applyDiff(diff)
		}
	}


/*

local key-value database

values can be arbitrary deep
uses arrays to escape changes
see diffRec unit tests for more info

*/	

	api createDb = func {
		history = llCreate('prev','next')
		root  = {}
		db = {
			enumKeys = func f { for k,v in root { f(k) } }
			get = func key { root[key] }
			set = func key, val { dbSetUsingDiff(db, key, val) }
			subscribe = func {
				snapShot = history.prev
				return {
					hasChanged = func { history.prev != snapShot }
					getDiff = func {
						it = snapShot.next
						if it == history { return nil }
						mergedDiff = {}
						while it != history {
							diffMerge(mergedDiff, it.forward)
							it = it.next
						}
						mergedDiff
					}
					rollback = func {
					
					}
					clearDiff = func { snapShot = history.prev }
//					remove = func { snapShot = nil }
				}
			}
			debug = func { root }
			getEntireDbAsJsonText = func { toJSON(root) }
			applyDiff = func diff {
											//print('applyD '..serialize(diff))
											//print(serialize(root))				
				llInsert(history, {
					forward = deepcopy(diff)  // don't do deepcopy here?
					reverse = applyDiffRec(root, diff)
				}, 'next', 'prev')
			}
		} 
		return db
	}

#####

		#{ js return { evalJs : dw_g_dnativeTextToFunc } #}

#####

api loadAndExecuteJavascript = func url, callback {
	http(url, nil, func err, txt {
		if not err {
			r = evalJs(txt)	
			if r.error {
		//		#{ js debugger #}
				callback(r.error)
			}		
			callback(nil, r.func)
		} else {
			callback(err)
		}
	})
}



#####

	kDbRevisionLen = 12

	syncDBToFile = func db, url, settings {  
		lastRev = nil

		handle = db.subscribe()
		lastSaveHandle = nil
		lastSaveRev = nil

		loadEntireDb = func url, retFunc {
			http(url, nil, func err, txt {
				if not err {
					revision = substring(txt, 0, kDbRevisionLen)
					if lastRev != revision {
			
						if settings.encryptionKey {
							txt = AesDecrypt(txt, settings.encryptionKey, settings.encryptionBits or 128)
						} else {
							txt = substring(txt, kDbRevisionLen)
						}

						entireDB = tryCall(fromJSON(txt))
						if entireDB.error {
							retFunc('loadEntireDb failed, could not interpret json-database ' .. url)
						} else {
							entireDB = entireDB.ret

							localChanges = nil
							if handle.hasChanged() {
								localChanges = handle.getDiff()
								if settings.mergeLocalChanges {
									applyDiffRec(entireDB, localChanges)  // apply local diff since last sync
								} else {
									handle.rollback() // undo local changes (means that local history will be flattened)
								}
							}

							dbSetEntireUsingDiff(db, entireDB)

							handle.clearDiff() // store this db-state so we can know what the local changes for future loads 

							if not settings.mergeLocalChanges {
								// todo make sure there are local changes
								//db.applyDiff(localChanges)  // apply local diff since last sync
							}

							retFunc(nil,'success') // pass entireDB to client?					
						}
					} else {
						retFunc(nil,'up to date')
					}
				} else {
					retFunc('loadEntireDb failed, database ' .. url .. ' not found')				
				}
			})
		}

		saveEntireDb = func url {
			jsonDB = []
			if not settings.encryptionKey {
				push(jsonDB, genRandomBase64urlString(kDbRevisionLen))
			}
			push(jsonDB, '{\n')
			db.enumKeys(func k {
				push(jsonDB, toJSON(k))
				push(jsonDB, ' = ')
				push(jsonDB, toJSON(db.get(k)))
				push(jsonDB, '\n')				
			})
			push(jsonDB, '}')	
			jsonDB = arrayConcatToString(jsonDB)	

			if settings.encryptionKey {
				jsonDB = AesEncrypt(jsonDB, settings.encryptionKey, settings.encryptionBits or 128)
			}

			lastSaveHandle = db.subscribe()
			lastSaveRev = substring(jsonDB, 0, kDbRevisionLen)

			serverJob('',[{type = 'file', sourceData = jsonDB, targetRelDir = url}], func error, ret {
				if not error {
					remove(handle)
					handle = lastSaveHandle
					lastRev = lastSaveRev
				} else {
					remove(lastSaveHandle)
				}
			})
		}

	}
/*
	createDiffDB = func baseDB {
		diff = {} // make this a database too?
		diffDbEnumKeys = func f {
			tmpDiff = copy(diff)
			baseDB.enumKeys(func key {
				d = tmpDiff[key]
				tmpDiff[key] = nil
				if not (type(d) == 'array' and len(d) == 0) { // check if deleted
					f(key)
				}
			})
			for key,v in tmpDiff { // enum objects added in diff, but not existing in base db 
				f(key)
			}
		}
		diffDbGet = func id {
			out = baseDB.get(id)
			delta = diff[id]
			if delta {
				out = patch(out or {}, delta)
			}
			return out
		}
	}
*/

#####

	copyHttpFragmentToDb = func db, stateDefaults {
		if not stateDefaults { throw('copyHttpFragmentToDb implement using db.enumKeys?') } 
		fragParams = uriToTable(getURLFragment())
		diff = {}
		hasContent = false
		for key,defVal in stateDefaults {
			val = fragParams[key] or defVal
			delta = diffRec(db.get(key), val)
			if delta != nil {
				diff[key] = delta
				hasContent = true
			}
		}
		if hasContent {
			db.applyDiff(diff)		
		}
	}

	copyDbToHttpFragment = func db, stateDefaults, omitDefaults {
		if not stateDefaults { throw('copyDbToHttpFragment implement using db.enumKeys?') } 
		params = {}
		for k,v in stateDefaults {
			params[k] = db.get(k)
		}
		if omitDefaults {
			for k,v in stateDefaults { 
				if deepequals(params[k], v) {
					params[k] = nil
				}
			}			
		}
		fragment = tableToUri(params)
		setURLFragment(fragment)
	}

	api syncDbToHttpFragment = func db, settings {
		prevFragment = nil
		dbListen = db.subscribe()
		curFragment = getURLFragment()
		if curFragment == '' {
			copyDbToHttpFragment(db, settings.stateDefaults, settings.omitDefaults)
			prevFragment = getURLFragment()
		} else {
			prevFragment = curFragment
			copyHttpFragmentToDb(db, settings.stateDefaults)	
			if settings.onDbChangedFromFragment { settings.onDbChangedFromFragment() }	
		}

		syncDbToHttpFragmentUpdate = func {
			if settings.blockUpdate and settings.blockUpdate() {
				return
			}
			curFragment = getURLFragment()
			if prevFragment != curFragment {
//				print('2db\n'..prevFragment..'\n'..curFragment)
				prevFragment = curFragment
				copyHttpFragmentToDb(db, settings.stateDefaults)
				if settings.onDbChangedFromFragment { settings.onDbChangedFromFragment() }	
			} else if dbListen.hasChanged() {
//				print('2frag')
				dbListen.clearDiff()
				copyDbToHttpFragment(db, settings.stateDefaults, settings.omitDefaults)
				prevFragment = getURLFragment()
			}
		}

		onInterval(settings.interval or 0.5, syncDbToHttpFragmentUpdate)

	}

	api createState = func db {
		defVals = {}
		reactiveValues = {}
		ctx = createHookContext()
		dbListen = db.subscribe()

		changed = {}
		syncWaiting = false
		syncStateAndDb = func {
			syncWaiting = false

			if dbListen.hasChanged() {
				for key, _diff in dbListen.getDiff() {
					if not changed[key] {
						set(reactiveValues[key], db.get(key))
					} else {
						// conflict, keep local changes, this did not happen yet
						print("conflict "..serialize(_diff))
					}

			// we might want to use the _diff if database items are deep and big
			// but if items are deep and big, notifications are not gonna work well anyway?
			//		cur = get(reactiveValues[key])
			//		if type(cur) == 'table' {
			//			applyDiffRec(cur, _diff)
			//			// how to invalidate?
			//		} else {
			//			set(reactiveValues[key], db.get(key))
			//		}

				}
			}

			diff = nil
			for key,v in changed {
				delta = diffRec(db.get(key), get(v))
				if delta != nil {
					if diff == nil { diff= {} } 
					diff[key] = delta
				}
			}
			if diff { db.applyDiff(diff) }
			changed = {}

			dbListen.clearDiff()
		}

		return {
			defaults = defVals
			sync = syncStateAndDb
			add = func spec {
				for databaseKey, reactiveValue in spec {
					defVals[databaseKey] = deepcopy(get(reactiveValue))
					reactiveValues[databaseKey] = reactiveValue
					hook(ctx, reactiveValue, func {
						changed[databaseKey] = reactiveValue
						if not syncWaiting {
							later(syncStateAndDb)
							syncWaiting = true
						}
					})
				}
			}
			remove = func { remove(ctx) }
		}
	}

	// simple web app with undo
/*
	s1 = create(1)
	s2 = create(2)
	s3 = create(3)
	db = createDb()
	state = createState(db) 
	state.add({s1 = s1, s2 = s2, s3 = s3})
	set(s1,'lax')
	set(s3,5)
	delay(5, func { set(s3, 6) })
	delay(10, func { set(s3, 3) })
	syncDbToHttpFragment(db, {interval = 0.5, stateDefaults = state.defaults, omitDefaults = true })
*/


#####




api detectArrayChange = func oldA, a, forceInvalidateAll {
	lenA = len(a)
	lenOldA = len(oldA)
	if forceInvalidateAll {
		return { pos = 0, oldSize = lenOldA, newSize = lenA}      
	}
	minLen = min(lenA, lenOldA)
	for i * minLen {
		if a[i] != oldA[i] {
			for j * minLen {
				if a[lenA-1-j] != oldA[lenOldA-1-j] {
				newSize = lenA-j - i
				oldSize = lenOldA-j - i
				if newSize < 0 { oldSize = oldSize - newSize; newSize = 0 }
				if oldSize < 0 { newSize = newSize - oldSize; oldSize = 0 }
				return { pos = i, oldSize = oldSize, newSize = newSize}
				}
			}
			if lenA > lenOldA {
				return { pos = i, oldSize = 0, newSize = lenA - lenOldA}
			} else {
				return { pos = i, oldSize = lenOldA - lenA, newSize = 0}
			}
		}
	}
	if lenA > lenOldA {
		return { pos = minLen, oldSize = 0, newSize = lenA - lenOldA}
	} else if lenA < lenOldA {
		return { pos = lenA, oldSize = lenOldA - lenA, newSize = 0}      
	}
}

#####

assert(serialize(detectArrayChange(split("a b c",       " "),split("a b b c",         " "))), '==', serialize({pos = 2, oldSize = 0, newSize = 1}))
assert(serialize(detectArrayChange(split("a b",         " "),split("_ a b",           " "))), '==', serialize({pos = 0, oldSize = 0, newSize = 1}))
assert(serialize(detectArrayChange(split("a b",         " "),split("a b c",           " "))), '==', serialize({pos = 2, oldSize = 0, newSize = 1}))
assert(serialize(detectArrayChange(split("a b b b c",   " "),split("a b c",           " "))), '==', serialize({pos = 2, oldSize = 2, newSize = 0}))
assert(serialize(detectArrayChange(split("a b b b c d", " "),split("a b c d",         " "))), '==', serialize({pos = 2, oldSize = 2, newSize = 0}))
assert(serialize(detectArrayChange([],                       split("a b",             " "))), '==', serialize({pos = 0, oldSize = 0, newSize = 2}))
assert(serialize(detectArrayChange(split("a b c d e f", " "),split("a b c d e f",     " "))), '==', 'nil')
assert(serialize(detectArrayChange(split("a b c d e f", " "),split("a b _ _ e f",     " "))), '==', serialize({pos = 2, oldSize = 2, newSize = 2}))
assert(serialize(detectArrayChange(split("a b c d e f", " "),split("a b e f",         " "))), '==', serialize({pos = 2, oldSize = 2, newSize = 0}))
assert(serialize(detectArrayChange(split("a b c d e f", " "),split("a b",             " "))), '==', serialize({pos = 2, oldSize = 4, newSize = 0}))
assert(serialize(detectArrayChange(split("a b c d e f", " "),split("a b _ _ _ _ e f", " "))), '==', serialize({pos = 2, oldSize = 2, newSize = 4}))
assert(serialize(detectArrayChange(split("a b c d e f", " "),split("a b _ f",         " "))), '==', serialize({pos = 2, oldSize = 3, newSize = 1}))
assert(serialize(detectArrayChange(split("a b c d e f", " "),split("_ _ _ f",         " "))), '==', serialize({pos = 0, oldSize = 5, newSize = 3}))
assert(serialize(detectArrayChange(split("a b c d e f", " "),split("_",               " "))), '==', serialize({pos = 0, oldSize = 6, newSize = 1}))
assert(serialize(detectArrayChange(split("a b",         " "),[]                           )), '==', serialize({pos = 0, oldSize = 2, newSize = 0}))
assert(serialize(detectArrayChange(split("a b e f",     " "),split("c d e f",         " "))), '==', serialize({pos = 0, oldSize = 2, newSize = 2}))


nil

#####

api arrayChangeToEvents = func refA, oldA, newA, insertFunc, removeFunc, changeFunc, similarEnough, forceInvalidateAll {
	diff = detectArrayChange(oldA, newA, forceInvalidateAll)
	if diff {
		offs = diff.pos
		potentialChangeCount = 0
		if similarEnough and not forceInvalidateAll {
	//		print(toStr({diff=diff,ol=oldA,ne=newA}))
			potentialChangeCount = min(diff.oldSize, diff.newSize)
			for ii * potentialChangeCount {
				i = offs == 0 ? potentialChangeCount - 1 - ii : offs + ii  // iterate backwards if offs == 0, to aid ordering
				if similarEnough(newA[i], oldA[i]) {
					changeFunc(i)
				} else {
					// replaced
					removeFunc(i)
					refA[i] = insertFunc(i, refA[i-1], refA[offs+potentialChangeCount]) // prev next refs is only to aid sorting, may be nil
				}
			}         	
		}
		offs = offs + potentialChangeCount
		for i * (diff.oldSize - potentialChangeCount), offs {
			removeFunc(i)
		}

		tailOffs = diff.pos + diff.newSize
		lenNewA = len(newA)
		sizeDiff = diff.newSize - diff.oldSize
		if sizeDiff > 0 {
			resize(refA, lenNewA)
			for i * (lenNewA - tailOffs) { refA[lenNewA - 1 - i] = refA[lenNewA - 1 - i - sizeDiff] }
		} else if sizeDiff < 0 {
			for i * (lenNewA - tailOffs) { refA[tailOffs + i] = refA[tailOffs + i - sizeDiff] }
			resize(refA, lenNewA)
		}

		nInsertions = (diff.newSize - potentialChangeCount)
		if offs == 0 and refA[tailOffs] != nil { // additions at the front need special handling, iterate backwards
			assert(tailOffs,'==',nInsertions)
//			for i = nInsertions - 1, 0, -1 { // loop not yet supported
			for ii * nInsertions { i = nInsertions - 1 - ii
				refA[i] = insertFunc(i, nil, refA[i+1]) // prev next refs is only to aid sorting
			}	
		} else {
			for i * nInsertions, offs {
				refA[i] = insertFunc(i, refA[i-1], refA[tailOffs]) // prev next refs is only to aid sorting
			}				
		}	
	}     
}

#####

api setupTextToDbSync = class rvText, codeDb, settings {

	settings = settings or {}
	codeDbListen = codeDb.subscribe()

	idToAttr = func id, diff, name {
		// first check if there is ongoing changes
		if diff and diff[id] {
			if type(diff[id]) == 'array' {
				ln = len(diff[id])
				if ln == 0      { return nil  }              // recently removed
				else if ln == 1 { return diff[id][0][name] } // recently created
				else { throw('idToAttr, assumed unused 1 '..toStr(diff)) } 
			} else if type(diff[id][name]) == 'array' {
				ln = len(diff[id][name])
				if ln == 0      { throw('idToAttr, assumed unused 2 '..toStr(diff)) ; return nil  } // recently removed
				else if ln == 1 { return diff[id][name][0] } // recently created
				else if ln == 2 and diff[id][name][0] == 0 { return diff[id][name][1] } // recently updated
				else { throw('idToAttr, assumed unused 3 '..toStr(diff)) } 
			} else {
				// object was changed, but not the attribute that was requested, should fallback on database
			}
		}
		item = codeDb.get(id)
		item and item[name]
	}

			//print(toStr(codeDb.debug()))

	treeSortCmp = func a, b {
		if a.root or b.root { return a.root ? true : false }
		assert(a.sPr,'!=',nil)
		assert(b.sPr,'!=',nil)
		assert(a.sPr,'!=',b.sPr)
		a.sPr > b.sPr
	}


	detectTree = settings.detectTree
	indentSpaces = settings.indentChars or 2
	oldRows = []
	rowRefs = []
	idToIndent = {}

	debugCounter = 100
	prevCodeText = ''

	expose syncNow = func {

		numChanges = 0
		firstChangePrevIndent = nil
		firstChangeOldInd = nil
		firstChangeKey = nil
		noStructuralChange = true
		newCodeText = get(rvText)
		forceInvalidateAll = settings.forceInvalidateAll and newCodeText != prevCodeText
		rows = split(newCodeText, '\n')
		dbDiff = {}
		inserted = func i, srPrev, srNext {
			noStructuralChange = false
//			id = createGlobalId()
			id = 'Id_' .. debugCounter .. ' ' .. rows[i] ; debugCounter = debugCounter + 1
			prevD = idToAttr(srPrev, dbDiff, 'sPr')
			nextD = idToAttr(srNext, dbDiff, 'sPr')
			lineText = rows[i]
			if detectTree {
				indent = countPadding(lineText, ' ')
				indf = indent / indentSpaces
				idToIndent[id] = floor(indf)
				dbDiff[id] = [{ dat = substring(lineText, indent), sPr = generateSortPrioBetween(prevD, nextD), pId = '?'}]
				if indf != idToIndent[id] { dbDiff[id][0].ind = indf - idToIndent[id] } // save sub-indentation				
			} else {
				dbDiff[id] = [{ dat = lineText, sPr = generateSortPrioBetween(prevD, nextD)}]				
			}
			id
		}
		removed = func i {
			noStructuralChange = false
			id = rowRefs[i]
			dbDiff[id] = []
			idToIndent[id] = nil
		}
		changed = func i {
			numChanges = numChanges + 1
			id = rowRefs[i]
			lineText = rows[i]
			if detectTree {
				oldInd = codeDb.get(id).ind
				if numChanges == 1 {
					// store some data needed for autoindent
					firstChangePrevIndent = idToIndent[id]
					firstChangeOldInd = oldInd
					firstChangeKey = id
				} 
				indent = countPadding(lineText, ' ')
				indf = indent / indentSpaces
				idToIndent[id] = floor(indf)
				dbChange = false
				tmp = {}
				newDat = substring(lineText, indent)
				if newDat != codeDb.get(id).dat { tmp.dat = [0,newDat] ; dbChange = true }
				newInd = nil
				if indf != idToIndent[id] { newInd = indf - idToIndent[id] } 	
				if oldInd != newInd { tmp.ind = diffRec(oldInd, newInd) ; dbChange = true }	
				if dbChange { dbDiff[id] = tmp }
			} else {
				dbDiff[id] = { dat = [0, lineText] }
			}
			id
		}
		similarEnough = func a, b {
			la = len(a)
			if la == 0 { return false } // if line is fully erased assign a new id
			lb = len(b)
			hs = floor(min(la, lb) / 3) 
//			if hs == 0 { return false } // if line is fully erased or too short to make meaningful comparisons, assign a new id
//			print(toStr(a).. ' '..toStr(b)..'  '..substring(a,0,hs)..'  '..substring(b,0,hs)..' , '..substring(a,-hs)..'  '..substring(b,-hs))
			substring(a,0,hs) == substring(b,0,hs) or substring(a,-hs) == substring(b,-hs) or false			
		}
		//print('rows1 '..toStr(rows))
		arrayChangeToEvents(rowRefs, oldRows, rows, inserted, removed, changed, similarEnough, forceInvalidateAll)
		//print('rows2 '..toStr(rows))
		oldRows = rows

		// detection for auto indent tree changes
		if settings.autoIndent and detectTree and numChanges == 1 and noStructuralChange {
			key = firstChangeKey
			if abs(idToIndent[key] - firstChangePrevIndent) == 1 and
			   firstChangeOldInd == nil and (dbDiff[key] == nil or dbDiff[key].ind == nil) and
			   (dbDiff[key] == nil or dbDiff[key].dat == nil) and
			   codeDb.get(key).dat != ""
			   {
				loop = true
				indentChildsOf = {}
				indentChildsOfNext = {}
				indentChildsOf[key] = true
				while loop {
					loop = false
					codeDb.enumKeys(func k {
						v = codeDb.get(k)
						if indentChildsOf[v.pId] {
							indentChildsOfNext[k] = true
							idToIndent[k] = idToIndent[k] + idToIndent[key] - firstChangePrevIndent
							loop = true
						}
					})
					indentChildsOf = indentChildsOfNext	
					indentChildsOfNext = {}
				}
			}
		}

//		remoteChange = codeDbListen.hasChanged()
//		#{ js debugger #}
//		print('diff '..toStr(dbDiff))
		codeDb.applyDiff(dbDiff)


		//print('\n'..toStr(codeDb.debug()))
//		if remoteChange {
			// rebuild oldRows and rowRefs from db
			oldRows = []
			rowRefs = []
			rawDb = codeDb.debug() // TODO: use enumKeys, or add query({filter:[])
//			print('hi '..toStr(rawDb))			

//			sortedForEach(rawDb, 'sPr', func id, row { // good opt, but stick to treeSortCmp to get assert
			sortedForEach(rawDb, treeSortCmp, func id, row {
				if not row.root {
					if detectTree {
						indentChars = rep(' ', idToIndent[id]*indentSpaces + (row.ind == nil or indentSpaces == 1 ? 0 : clamp(row.ind*indentSpaces,1,indentSpaces-1) ) )
						push(oldRows, indentChars .. row.dat)					
					} else {
						push(oldRows, row.dat)										
					}
					push(rowRefs, id)					
				}
			})
			prevCodeText = arrayConcatToString(oldRows, '\n') 
			set(rvText, prevCodeText)
//		}

		if detectTree {
			dbDiff = nil
			skipRows = {}
			if len(rowRefs) != 0 {
				depthOffset = (idToIndent[rowRefs[0]] + (idToAttr(rowRefs[0], dbDiff, 'ind') or 0)) * indentSpaces
				stack = ['codeRoot']
				for i = 1, len(rowRefs)-1 {
					refId = rowRefs[i]
					curDepth = (len(stack) - 1) * indentSpaces
					depth = (idToIndent[refId] + (idToAttr(refId, dbDiff, 'ind') or 0)) * indentSpaces - depthOffset
					newPId = nil
					if idToAttr(refId, dbDiff, 'dat') == '' { // special case for empty lines, put them under current depth, and never use them as parents
						skipRows[i] = true
					}
					if depth == curDepth or skipRows[i] {
						newPId = getLast(stack)
					} else if depth == curDepth + indentSpaces {
						j = i - 1
						while skipRows[j] and j > 0 { j = j - 1}
						push(stack, rowRefs[j])
						newPId = getLast(stack)
					} else {
						indentChange = (curDepth - depth) / indentSpaces
						newStackLen = len(stack) - indentChange
						if isInt(indentChange) and indentChange > 0 and newStackLen > 0 {
							resize(stack, newStackLen)
							newPId = getLast(stack)
						} else {
							newPId = '?'
						}
					}

					if newPId != idToAttr(refId, dbDiff, 'pId') {
						dbDiff = dbDiff or {}
						dbDiff[refId] = dbDiff[refId] or {}
						dbDiff[refId].pId = [0,newPId]
					}
				}		
			}

			if dbDiff {
//				print('diff '..toStr(dbDiff))
				codeDb.applyDiff(dbDiff)
			}			
		}



		codeDbListen.clearDiff() 
	}
}

nil

#####

api createFixedFont = func chars, resource, f {
	glyphs = {}
	getImage(resource, nil, func err, a { 
			if err {
				f(nil)
				return
			}

			for i * len(a) {
				glyphs[charCodeAt(chars,i)] = { imageFrag = a[i], advanceX = a[i].w }	
			}
			f({ glyphs = glyphs })
		}, { hStrip = len(chars) })
}

api drawText = func bd, font, text, x, y, spacing {
	for i * len(text) {
		charCode = charCodeAt(text, i)
		glyph = font.glyphs[charCode]
		if glyph {
			bd.drawImage(glyph.imageFrag, x, y)
			x = x + glyph.advanceX + (spacing ?: 0)
		} else {
			bd.fillRect(x,y,10,10)
		}
	}
}

#####

//successfullCount = 0
//failedCount = 0
//
//api unitTest = func testName, codeAsText, expectedToBe {
//	a = textToFunc(codeAsText)
//	if a.error {
//		if expectedToBe == 'PARSE_FAIL' {
//			a = 'PARSE_FAIL'
//		} else {
//			print('error unitTest(): ' .. testName .. '  ' .. a.error .. '\n')	
//			failedCount = failedCount + 1;
//			return nil
//		}
//	} else {
//		a = tryCall(a.func)
//		if a.error {
//			print('error executing: ' .. testName .. '  ' .. a.error .. ' ' .. codeAsText .. '\n')	
//			failedCount = failedCount + 1;
//			return nil
//		} else {
//			debug(codeAsText .. "    // " .. testName .. ' ' .. (expectedToBe==nil and 'nil' or expectedToBe));   //  .. '// ' .. (expectedToBe or 'nil')
//			a = a.ret
//		}
//	}
//	if a != expectedToBe { 
//		print(testName .. ': result expected to be:\n' .. expectedToBe  .. '\n\n was \n' .. a .. ')\n')
//		failedCount = failedCount + 1
//	} else {
//		successfullCount = successfullCount + 1
//	}
//}
//					
//api unitTestReport = func { 
//	print('' .. successfullCount .. ' passed')
//	if failedCount != 0 {
//		print('' .. failedCount .. ' failed')
//	}
//}
//


//////////////////////////////////////


#####

global htmlDevTools = { 
	enabled = false
	version = 1
	printedLines = []   // <string>, ...
	actionButtons = []  // { dispName = <string>, fn = <func>, fnGet = <func> } , ...  
	coord = [97, 3]     // percent
	size = 'closed'		// 'closed', 'small', 'big'
}


prevVersion = 0

htmlDevTools.forceUpdate = func {
	domNode = domGet('###html_extra')
	if domNode {
		lines = htmlDevTools.printedLines
		lineCount = nil
		lineCount = lineCount or len(lines)
		ln = 500
		str = "<div style='width:" + (ln + 20) + "px;'/><div style='width:" + (ln) + "px;padding:8px;background-color:#282828;position:fixed; right:5px; top:5px; bottom:5px; overflow:auto;'><pre>";
		for i * lineCount {
			id = lines.length - lineCount + i
			if(id >= 0 and id < lines.length) {
				str = str + lines[id]  + '\n'
	//			str = str + lines[id].replace(/\n/g, '<br />') + '<br />'
			}
		}
		str = str + "</pre> <br /><br /><br /><br />";
		str = str + "<textarea style=\"width:100%;height:50%;\" id=\"textout\"><\/textarea>   </div>    </div>\n"
		domNode.innerHTML = str	
	}
	prevVersion = htmlDevTools.version
}




htmlDevTools.update = func {
	if htmlDevTools.version != prevVersion {
		htmlDevTools.forceUpdate()
	} 
}



#####


createGL = func canvas, opt {
  names = ["webgl", "experimental-webgl", "webkit-3d", "moz-webgl"];
  ctx = nil;
  for i * len(names) {
    tryCall( func { ctx = canvas.getContext(names[i], opt) })
    if ctx { return ctx }
  }
}	

glState = class {

  gl = createGL()
  glnull = {}

  curSpec = {}
  curObjs = {}

  createFuncs = {
    texture = func spec {
      out = {}
      w = spec.w or 256
      h = spec.h or 256
      useFloat = spec.type == 'float' or spec.type == 'float4'

      if spec.hasFramebuffer {
        out.glFrameBuffer = gl.createFramebuffer();
        gl.bindFramebuffer(gl.FRAMEBUFFER, out.glFrameBuffer);        
      }

      out.glTexture = gl.createTexture();
      gl.bindTexture(gl.TEXTURE_2D, out.glTexture);
      if useFloat {
      	// only nearest seem to work with float
      	// and this is often what you want anyway
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST); 
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);        
      } else {
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
        if not spec.useMipmaps {
          gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
        } else {
          gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR_MIPMAP_NEAREST);
          gl.generateMipmap(gl.TEXTURE_2D);          
        }
      }

      if useFloat {
		float_texture_ext = gl.getExtension('OES_texture_float'); // calling this makes this extension available in the context
		gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, w, h, 0, gl.RGBA, gl.FLOAT, glnull)
      } else {
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, w, h, 0, gl.RGBA, gl.UNSIGNED_BYTE, glnull);
      }

      if spec.hasDepthBuffer {
         depthBuf = gl.createRenderbuffer();
         gl.bindRenderbuffer(gl.RENDERBUFFER, depthBuf);
         gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_COMPONENT16, w, h);
         gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.RENDERBUFFER, depthBuf);
      }

      if spec.hasFramebuffer {
          gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, out.glTexture, 0);
      }

        gl.bindTexture(gl.TEXTURE_2D, glnull);
        gl.bindRenderbuffer(gl.RENDERBUFFER, glnull);
        gl.bindFramebuffer(gl.FRAMEBUFFER, glnull);     

        return out  
    }
  }

  glCreateObject = func spec {
    if spec.t == 'texture' {

    }
  }

  glUpdateObj = func obj, spec, diff {

  }

  expose applySpec = func {

  }
//  expose update = class spec {
//    t = type(spec)
//    if t == 'array' { for i * len(spec) { glUpd(spec[i]) }
//    } else if t == 'table' {              glUpd(spec)
//    } else { throw('glContext:update wrong type: '..t) }
//  }
  
}

#####

// move this to js or make it possible to disable profiling somehow
// everything we do here to process profiling data will also be profiled!

sortIdle = func a,b { a.idle < b.idle ? 1 : -1 }
sortDraw = func a,b { a.draw < b.draw ? 1 : -1 }
sortIdleAndDraw = func a,b { a.idleAndDraw < b.idleAndDraw ? 1 : -1 }
sortFrameTime = func a,b { a.frameTime < b.frameTime ? 1 : -1 }

global profilingSwap = func frames, funcInfo {
  for _, frame in frames {
   frame.idle = frame.t3 - frame.t2
   frame.draw = frame.t4 - frame.t3
   frame.idleAndDraw = frame.t4 - frame.t2
   frame.frameTime = frame.t5 - frame.t1  // excluding t0 (profilingSwap) -- method to obtain frameTime and excluding profiling is flawed
  }

  framesByIdle        = sorted(frames, sortIdle)
  framesByDraw        = sorted(frames, sortDraw)
  framesByIdleAndDraw = sorted(frames, sortIdleAndDraw)
  framesByFrameTime   = sorted(frames, sortFrameTime)  
  print('idle         : '..formatMs(getMiddle(framesByIdle).idle)..' ('..formatMs(getLast(framesByIdle).idle)..' '..formatMs(framesByIdle[0].idle)..')')
  print('draw         : '..formatMs(getMiddle(framesByDraw).draw)..' ('..formatMs(getLast(framesByDraw).draw)..' '..formatMs(framesByDraw[0].draw)..')')
  print('idleAndDraw  : '..formatMs(getMiddle(framesByIdleAndDraw).idleAndDraw)..' ('..formatMs(getLast(framesByIdleAndDraw).idleAndDraw)..' '..formatMs(framesByIdleAndDraw[0].idleAndDraw)..')')
  print('frameTime    : '..formatMs(getMiddle(framesByFrameTime  ).frameTime  )..' ('..formatMs(getLast(framesByFrameTime  ).frameTime  )..' '..formatMs(framesByFrameTime  [0].frameTime  )..')')

  if funcInfo {
    framesTime = getLast(frames).t5 - frames[0].t1
    maxDiff = -1
    maxDiffItem = nil
    maxDiffCalls = nil
    maxCalls = -1
    maxCallsItem = nil
    totalCalls = 0
    for ttfId, funcsCol in funcInfo {
      for funcName, funcsCol2 in funcsCol {
		if	funcName != 'profilingSwap' and 
			funcName != 'sortIdle' and 
			funcName != 'sortDraw' and 
			funcName != 'sortIdleAndDraw' and 
			funcName != 'sortFrameTime'
		{
			num = len(funcsCol2.events or [])
			if num > maxCalls {
				maxCalls = num
				maxCallsItem = {id = ttfId, name = funcName}
			}
			for i * num {
			totalCalls = totalCalls + 1
			data = funcsCol2.events[i]
			diff = data.t2 - data.t1
			if(diff > maxDiff) {
				maxDiff = diff
				maxDiffItem = {id = ttfId, name = funcName}
			}
		  }
		}
      }
    }
    
  print('Calls per sec: '..formatNice(totalCalls/framesTime))
  print('Most called  : '..maxCallsItem.name..', '..formatNice(maxCalls/framesTime)..' per sec ('..maxCallsItem.id..')')
  print('Largest spike: '..maxDiffItem.name.. ', '..formatMs(maxDiff)..' ('..maxDiffItem.id..')')
  print('')
  }
}

#####



//
//
//         GUISYSTEM
//

//   USAGE of LocalDrawContext: 
//
//    imgBack = ctx.createDrawable()
//    text    = ctx.createDrawable()
//    ctx.bindUpdateFunction([imgBack, text], func {
//      imgBack.update('image', hasBackground ? { ... } : nil) if imgBack.needUpdate
//      text   .update('text',  hasText       ? { ... } : nil) if text.needUpdate
//    })
//    input ... {
//      text.needDraw() // requests a redraw of the context(s), and schedules updateDraw 
//    }


basicDrawCtx = nil

api RemoteDrawContext = class {

	drawableRoot = { t = 'group' }
	idToDrawable = { root000 = drawableRoot}

	drawableIdCounter = 0

	dpi = 1 // there is already support for scaling in the canvas api, use that instead?

	expose getDPI = func newDpi { dpi }

	expose setDPI = func newDpi {
		dpi = newDpi
	}

	expose setDrawBackend = func drawCtx {
		basicDrawCtx = drawCtx
	}

	expose createSysDrawable = func parentId, idOverride {
	    drawableIdCounter = drawableIdCounter + 1
	    newId = idOverride ?: 'd'+drawableIdCounter
	    newDrawable = { id = newId, t = 'group' }
	    parent = parentId == nil ? drawableRoot : idToDrawable[parentId]
	    parent.order    = parent.order    ?: llCreate('prev', 'next')
	    llInsert(parent.order, newDrawable, 'prev', 'next')
//	    parent.subNodes = parent.subNodes ?: {}
//	    parent.subNodes[newId] = newDrawable
	    idToDrawable[newId] = newDrawable
	    trace(guisystem, 'createDrawable '..newId)
//	    if newId == 'd3' {
//	      #{ js debugger #}
//	    }
	    return newId
	}

	expose updateSysDrawable = func id, type, data {
	    trace(guisystem, 'updateDrawable '..id..' '..type)
	    drawable = idToDrawable[id]
	    drawable.t = type
	    drawable.d = data

        // don't invalidate here, updateSysDrawable is designed to be called from draw
//		global __wantDraw = true   	    
	}

	expose removeSysDrawable = func id {
	    trace(guisystem, 'removeSysDrawable '..id)
	    drawable = idToDrawable[id]
		llUnlink(drawable, 'prev', 'next')
		idToDrawable[id] = nil
		global __wantDraw = true

		// remove subtree?  just leave to GC for now...
	}

/*
	drawState = {
		x = 0
		y = 0
		color = '#F90'    // option to inherit colors?
		colorValid = false
	}
*/

	primitiveRenderers = {

	    group = func {

	    }
/*
	    translate2D = func d {
	      curX = drawState.x
	      curY = drawState.y
	      drawState.x = curX + d.x
	      drawState.y = curY + d.y
	      {x = curX, y = curY}
	    }
*/
	    circle = func d {
			if d.radius <= 0 { return }
	    	basicDrawCtx.fillEnable(true)
	    	basicDrawCtx.strokeEnable(false)
	    	basicDrawCtx.fillColor(d.color or '#FFF')
	    	basicDrawCtx.fillAlpha(d.opacity != nil ? d.opacity : 1) // skip? color already support alpha? 	    	
	    	basicDrawCtx.circle(d.x * dpi, d.y * dpi, d.radius * dpi)
	    }

	    line = func d {
	    	basicDrawCtx.fillEnable(false)
	    	basicDrawCtx.strokeEnable(true)
	    	basicDrawCtx.strokeColor(d.color or '#FFF')
	    	basicDrawCtx.strokeAlpha(d.opacity != nil ? d.opacity : 1)
	    	basicDrawCtx.strokeWidth((d.width or 2) * dpi)
	    	basicDrawCtx.beginPath()
	    	basicDrawCtx.moveTo(d.x1 * dpi, d.y1 * dpi)
	    	basicDrawCtx.lineTo(d.x2 * dpi, d.y2 * dpi)
	    	basicDrawCtx.endPath()
	    }

	    rect = func d {
	    	// handle state?

	    	// col = d.color
	    	// oldCol = nil
	    	// if col { oldCol = drawState.color ; drawState.col = col ; drawState.colorValid = false }
	    	// if drawState.colorValid == false { basicDrawCtx.fillColor(drawState.color) }
	    	// basicDrawCtx.fillRect(d.x * dpi, d.y * dpi, d.w * dpi, d.h * dpi)
	    	// if oldCol { drawState.color = oldCol ; drawState.colorValid = false }

	    	basicDrawCtx.fillEnable(true)
	    	basicDrawCtx.strokeEnable(false)
	    	basicDrawCtx.fillColor(d.color)
	    	basicDrawCtx.fillAlpha(d.opacity != nil ? d.opacity : 1)
	    	basicDrawCtx.fillRect(d.x * dpi, d.y * dpi, d.w * dpi, d.h * dpi)
	    }

	    shape = func d {
	    	basicDrawCtx.fillEnable(true)
	    	basicDrawCtx.strokeEnable(false)
	    	basicDrawCtx.fillColor(d.color or '#FFF')
	    	basicDrawCtx.fillAlpha(d.opacity != nil ? d.opacity : 1)
			pts = d.points
			N = len(pts)
			if N >= 2 {
				basicDrawCtx.beginPath()
				i = 0
				while i < N {
					basicDrawCtx.moveTo(pts[i] * dpi, pts[i + 1] * dpi)
					i = i + 2
					while i < N {
						if pts[i] == nil {
							i = i + 2
							break;
						}
						basicDrawCtx.lineTo(pts[i] * dpi, pts[i + 1] * dpi)
						i = i + 2
					}
				}
				// basicDrawCtx.closePath()
			}			
			//basicDrawCtx.fill()
			basicDrawCtx.endPath()
	    }

		
	}

	renderDrawTreeRec = nil
	renderDrawTreeRec = func node {
		if node == nil { throw('renderDrawTreeRec()'..(node.id) .. ' ' .. 'missing') }
		t = node.t
//		trace(guisystem, 'renderDrawTreeRec '..toStr(node))
		f = primitiveRenderers[t]
		if not f { throw('no such rendering backend:'..node.t) }

		popState = f(node.d)  // <-- rendering

		order = node.order
		llForEachFast(order, renderDrawTreeRec, 'prev', 'next') if order

//		extend(drawState, popState) if popState
		nil
	}

	bgColor = '#000'

	expose setBackgroundColor = func c {
		if c != bgColor {
			bgColor = c
			global __wantDraw = true
		}
	}

	expose draw = func {
		basicDrawCtx.fillColor(bgColor or '#000') // actual background
		basicDrawCtx.fillAlpha(1)
		basicDrawCtx.fillRect(0, 0, basicDrawCtx.getWidth(), basicDrawCtx.getHeight())
		renderDrawTreeRec(idToDrawable['root000'])
	}
}



#####



beforeNextDrawBeginList = []
beforeNextDrawBegin = func f {
	global __wantDraw = true
	push(beforeNextDrawBeginList, f)
}


//id = remoteDrawContext.createSysDrawable()
//remoteDrawContext.updateSysDrawable(id, 'rect', {x=40, y=40, w = 100, h = 100, col = '#FFF'})


// use plain array [a,b,c,d,e,f] for 2d transform (order is same as svg and canvas specs)
// a c e
// b d f
// 0 0 1


apply2dScale        = func m, p { [p[0]*m[0] + p[1]*m[2]       ,  p[0]*m[1] + p[1]*m[3]       ] }
apply2dTransform    = func m, p { [p[0]*m[0] + p[1]*m[2] + m[4],  p[0]*m[1] + p[1]*m[3] + m[5]] }
transformToMat      = func a { [[a[0], a[2], a[4]],
                [a[1], a[3], a[5]], 
                [0,    0,    1   ]] }
matToTransform      = func m { [m[0][0], m[1][0], m[0][1], m[1][1], m[0][2], m[1][2] ] }
combine2dTransforms = func a, b { matToTransform(matrixMul(transformToMat(a), transformToMat(b))) } // todo optimize?
t2dTranslate  = func x, y {                       [1, 0, 0, 1, x, y] }
api t2dRotate     = func a    { s=sin(a) ; c=cos(a) ; [c, s,-s, c, 0, 0] }
api t2dScale      = func x, y {                       [x, 0, 0, y, 0, 0] }
api v2add = func a, b { [a[0]+b[0], a[1]+b[1]] }
api v2sub = func a, b { [a[0]-b[0], a[1]-b[1]] }

api inputHitTestPointToPoint = func a, b, inputFuzzMarginSquared, radius {
  xd = a[0] - b[0]
  yd = a[1] - b[1]
  magsqr = xd*xd + yd*yd
  if magsqr < inputFuzzMarginSquared {
   return sqrt(magsqr / inputFuzzMarginSquared) +
   			 0.15 * linearstep(6, 70, radius)  // increase prio of small circles (helps for overlapping)
  }
}

api LocalDrawContext = class parentSysDrawable, remoteDrawContext {

/*

This currently does nothing, but prepared to be a kind of transform stack
(but in declarative version, it would be uiContext instances in the block tree,
resulting in something similar to how transforms work in game engines)

most performant impl alternative would be:
	* drop potential perspective support
	* add setTransform(a,b,c,d,e,f) to basicDraw interface (and use native canvas impl transforms)
	* let this context handle input transform only

*/


	inpM  = [1,0,0,1,0,0]
	inpIm = [1,0,0,1,0,0]

//	pixM  = [1,0,0,1,0,0]
//	pixIm = [1,0,0,1,0,0]


	inputFuzzMargin = 50  // extend ui area of components, good for touch interaction of smaller objects


/*

	minCapHeight = 0.05
	minXHeight = 0.03

	localM = []

	expose updateLocalMatrix = func x, y, sx, sy, hx, hy, rot {
		m = t2dTranslate(-hx, -hy)
		if sx != 1 or sy != 1 { m = combine2dTransforms(m, t2dScale(sx, sy)  ) }
		if rot != 0           { m = combine2dTransforms(m, t2dRotate(rot)    ) }
		if x != 0 or y != 0   { m = combine2dTransforms(m, t2dTranslate(x, y)) }
		localM = m
	}

	transformListeners = llCreate('prev', 'next')
	expose hookTransformChange = func f {
		item = { f = f }
		llInsert(transformListeners, item, 'prev', 'next')
		item.remove = func { llUnlink(item, 'prev', 'next') }
		return item
	}
*/


/*
	expose createLayoutable = func interface { // rvMin, rvMax,
		// get prev layoutable using namespace
	} 


		each localContext has layoutstate and manages layouting of its layoutables

        parent -> baseSize
		          baseSize* -> layoutChildren
		          wantSize* <- layoutChildren
		          needSize* <- layoutChildren

		parent <- wantSize 
		parent <- needSize 

        parent -> pos  / size
                  pos* / size* -> layoutChildren


        maybe this flow should not be based on reactive values,
        since we might want to apply the final values as animation.

        does this mean we want to have an extra set of pos/size/opacity etc
        parameters, that is written by the animationhandler?

	*/
	
//	pos       = create([0, 0]) // in parent coord space
//	size      = create([1, 1]) // in parent coord space
//	handlePos = create([0, 0]) // in relation to size, (0.5, 0.5) means centered
//	rotation  = create( 0 )      // rotation around handle
//	cmin      = create([0, 0])
//	cmax      = create([1, 1])

//	updateLocalMatrix = func {
//		lPos = get(pos)
//		lSize = get(size)
//		lHandlePos = get(handlePos)
//		lRotation = get(rotation)
//		m = t2dTranslate(-lHandlePos[0], -lHandlePos[1])
//		m = combine2dTransforms(m, t2dScale(lSize[0], lSize[1]))
//		if lRotation != 0 { m = combine2dTransforms(m, t2dRotate(lRotation)) }
//		m = combine2dTransforms(m, t2dTranslate(lPos[0], lPos[1]))
//	}

//	hookMultiple(gHookContext, [pos, size, handlePos, rotation, cmin, cmax], 0, updateLocalMatrix)

//	expose setCoordinateSystem = func x0, y0, x1, y1, parentMatrix, contextW, contextH {
//	}

	expose bindUpdateFunction = func drawables, fnc {
		removed = false
		updater = { queued = true }
		updater.f = func { if not removed { fnc() ; updater.queued = false } }
		beforeNextDrawBegin(updater.f)
		for item in drawables {
			item.updater = updater	
		}
		; // parsebug
		return { 
			remove = func {
				removed = true
				for item in drawables {
					remove(item)
				}			
			}
		}
	}

	expose getInputFuzzMargin  = func { inputFuzzMargin }
//	expose getMinCapHeight     = func { minCapHeight }
//	expose getMinXHeight       = func { minXHeight }
//	expose pixelSnap           = func p { p = apply2dTransform (pixM, p) ; p[0] = floor(p[0]) ; p[1] = floor(p[1]) ; apply2dTransform (pixIm, p) }   
	expose fromInput           = func s { apply2dTransform (inpIm, s) }
	expose fromInputScaleOnly  = func s { apply2dScale     (inpIm, s) } // interface assumes uniform scale (needs pos to support perspective)
	expose toInput             = func s { apply2dTransform (inpM,  s) }
	expose toInputScaleOnly    = func s { apply2dScale     (inpM,  s) } // interface assumes uniform scale (needs pos to support perspective)
	expose toInputScalar       = func s { s * inpM[0]                 } // interface assumes uniform scale, current impl assumes no rotation!, maybe not use matrices? or at least also story scale multiplier

	debugCount = 0
	expose createDrawable = func {
	  debugCount = debugCount + 1
	  debugCount2 = debugCount
	  drawable = nil
	  wrapper = { needUpdate = true, updater = { queued = true }, debugCount = debugCount }
	  wrapper.needDraw = func {
	    if not wrapper.updater.queued {
	      beforeNextDrawBegin(wrapper.updater.f)
	      wrapper.updater.queued = true
	      wrapper.needUpdate = true
	    }
	  }
	  wrapper.update = func type, data {
	  	if data == nil {
	  		if drawable {
		  		remoteDrawContext.removeSysDrawable(drawable) ; drawable = nil 
	  		}
	  	} else if drawable == nil {
//	  		print('createSysDrawable '..debugCount2..' '.. wrapper.debugCount)
	  		drawable = remoteDrawContext.createSysDrawable(parentSysDrawable)
	  	}
	    remoteDrawContext.updateSysDrawable(drawable, type, data) if drawable and data
	    wrapper.needUpdate = false
	  }
	  wrapper.remove = func { 
	  	if drawable {
	  		remoteDrawContext.removeSysDrawable(drawable) ; drawable = nil 
	  	}
	  }
	  return wrapper
	}	

}


api createSimpleGuiSystem = func basicDraw {

	remoteDrawContext = new RemoteDrawContext
	remoteDrawContext.setDrawBackend(basicDraw)

	drawEvent.register(func {
	 for i * len(beforeNextDrawBeginList) { beforeNextDrawBeginList[i]() }
	 beforeNextDrawBeginList = []

	 remoteDrawContext.draw()

	// basicDrawCtx.fillColor(random() > 0.5 and '#FFAA00' or '#666666')
	// basicDrawCtx.fillAlpha(1)
	// basicDrawCtx.fillRect(10+random()*10,10+random()*10,120,120)
	})

	initGlobalTimers()

	inputListeners = llCreate('_inputPrev','_inputNext')
	currentCapture = {}
	removedFromInputListeners = func obj { obj._inputPrev == nil }
	inputAddDragListener = func obj {
		llInsert(inputListeners, obj, '_inputPrev','_inputNext')
		{
			remove = func { llUnlink(obj,'_inputPrev','_inputNext') }
		}
	}

	global inputHandler = func id, pos, a3 {
		dpi = remoteDrawContext.getDPI()
		apos = [pos.x / dpi, pos.y / dpi]
		if a3 == true {
			minDist = 99999999999999
			minItem = nil
			llForEachFast(inputListeners, func item {
				res = item.inputTest(id, apos)
//				print('inputTest '..res)
				if res and res < minDist {
					minItem = item
					minDist = res
				}
			}, '_inputPrev','_inputNext')
			if minItem {
				currentCapture[id] = [minItem] // todo, fix? array no longer needed?
				minItem.inputDrag(id, 'start', apos)
			} else {
				currentCapture[id] = nil		
			}
		} else if a3 == false {
			for obj in currentCapture[id] or {} {
				obj.inputDrag(id, 'stop', apos) if not removedFromInputListeners(obj)
				currentCapture[id] = nil		
			}
		} else {
			for obj in currentCapture[id] or {} {
				obj.inputDrag(id, 'drag', apos) if not removedFromInputListeners(obj)
			}
		}
	}

	createLocalDrawContext = func parent {
		assert(parent)
		return new LocalDrawContext(parent, remoteDrawContext)
	}

	rootDrawCtx = new LocalDrawContext(nil, remoteDrawContext)

	return {
		inputAddDragListener = inputAddDragListener
		createLocalDrawContext = createLocalDrawContext
		getRootDrawContext = func { rootDrawCtx }
		draw = func { remoteDrawContext.draw() }
		setBackgroundColor = func c { remoteDrawContext.setBackgroundColor(c) }
		setDPI = func dpi { remoteDrawContext.setDPI(dpi) }
		getDPI = func dpi { remoteDrawContext.getDPI(dpi) }
		isAnyDown = func { 
			// for k,v in currentCapture { print('currentCapture '..len(currentCapture)..' '..k..' '..v) }
			return len(currentCapture) > 0
		}
	}

}

#####

// keep this abstraction clean from reactive values?
// would be simpler with reactive values, but also less ergonomic...

api createUIElement = func options {
	ui = options.ui or gGui
	ctx = options.drawContext or gGui.getRootDrawContext()

	posInputValid = false
	lastDragMyPosIS = nil
	lastDragInputIS = nil	

	down = false
	clickTimeout = options.clickTimeout or 999
	unintentionalDragThreshold = options.unintentionalDragThreshold or 10
	dragDistance = 0
	downTimeStamp = 0
	userIntentionIsDrag = false

	posIS = [0,0]
	ppos = options.position or [0,0]
	ssize = options.size or [0,0]
	element = {
		setPosition = func p { assert(type(p), '==', 'array') assert(isFiniteNumber(p[0])); assert(isFiniteNumber(p[1])); ppos[0] = p[0] ; ppos[1] = p[1] ; posInputValid = false }
		getPosition = func   { [ppos[0], ppos[1]] }
		setSize = func p { ssize[0] = p[0] ; ssize[1] = p[1] }
		getSize = func   { [ssize[0], ssize[1]] }
		isDown = func { down }
		isDragged = func { userIntentionIsDrag }
		timeSinceOnDown = func { getTime() - downTimeStamp }
	}	
	validateISCoord = func { posIS = ctx.toInput (ppos) ; posInputValid = true } 
	if options.hitInput == 'circle' {
		element.inputTest = func id, pos {
			if not down {
				if not posInputValid { validateISCoord() }
				radius = 8
				return inputHitTestPointToPoint(pos, posIS, square(radius + ctx.getInputFuzzMargin()), radius)
			}
		}	
	} else { // rect
		element.inputTest = func id, pos {
			if not down {
				if not posInputValid { validateISCoord() }
				size = element.getSize()
				margin = ctx.getInputFuzzMargin()

				// polygon check instead of rect - we want to support rotated and 3D perspective transforms
				quad2 = ctx.toInput([ppos[0] + size[0], ppos[1]])
				quad3 = ctx.toInput([ppos[0] + size[0], ppos[1] + size[1]])
				quad4 = ctx.toInput([ppos[0], ppos[1] + size[1]])
				dist = distToQuad(pos[0], pos[1], margin, posIS[0], posIS[1], quad2[0], quad2[1], quad3[0], quad3[1], quad4[0], quad4[1])
				if dist != nil {
					// reduce priority of large rects (good for touch input vs small items)
					// definition of small is hardoded: 30 units
					dist = dist + 0.5 * margin * (1 - min(1, 30 / max(size[0], size[1])))
				}
				return dist
			}
		}
	}


	clientEvents = {} 
	element.inputDrag = func id, event, pos {
		if not posInputValid { validateISCoord() }
		if event == 'start' or event == 'stop' { 
			// ppos = mPos.get() 
			posInputValid = false; 
			down = event == 'start'
			clientEvents.onIsDownChanged() if clientEvents.onIsDownChanged
			if event == 'start' {
				clientEvents.onDown() if clientEvents.onDown
				assert(userIntentionIsDrag == false)
				dragDistance = 0
				downTimeStamp = getTime()
			} else { // stop
				clientEvents.onUp() if clientEvents.onUp
				if userIntentionIsDrag {
					userIntentionIsDrag = false
					clientEvents.onIsDraggedChanged() if clientEvents.onIsDraggedChanged
					clientEvents.onDragEnd() if clientEvents.onDragEnd	
				} else {
					if clientEvents.onClicked and getTime() - downTimeStamp < clickTimeout {
						clientEvents.onClicked()
					}
				}
			}
		 } else {
			diffDragIS = v2sub(pos, lastDragInputIS)
			if not userIntentionIsDrag {
				// detect if user intentionally starts dragging
				dragDistance = dragDistance + abs(diffDragIS[0]) + abs(diffDragIS[1])
				if dragDistance > unintentionalDragThreshold {
					userIntentionIsDrag = true
					clientEvents.onIsDraggedChanged() if clientEvents.onIsDraggedChanged
					clientEvents.onDragBegin() if clientEvents.onDragBegin
				}
			}
			diffMyIS = v2sub(posIS, lastDragMyPosIS)
			ppos = v2add(ppos, ctx.fromInputScaleOnly(v2sub(diffDragIS, diffMyIS)))
			validateISCoord()

			clientEvents.onMoved() if clientEvents.onMoved

			// mPos.set(ppos)
		}
		lastDragMyPosIS = posIS
		lastDragInputIS = pos
	}	
	inputHandle = ui.inputAddDragListener(element)
	element.bindDrawables = func items, updateFunc {
		remove(element.drawBindings)
		element.drawBindings = ctx.bindUpdateFunction(items, updateFunc)
	}
	if options.onInit {
		clientEvents = options.onInit(element, ctx) or {}
	}
	element_remove = func { 
		clientEvents.onRemove() if clientEvents.onRemove
		remove(element.drawBindings)
		remove(inputHandle)
	}

	element.remove = element_remove
	return element
}

#####

api draggableDividerAndBackground = func options {

	cornerPos = [40, 40]
	circleVsBottomOffset = 12

	dragAndAnimateTextPane = createUIElement({
		position = [cornerPos[0], (options.defaultHeight or 300) + circleVsBottomOffset]
		hitInput = 'circle'
		draggable = true
		onInit = func self, ctx {
			iconScale = options.iconScale or 1
			icon = ctx.createDrawable()
			bg = ctx.createDrawable()

			reactiveRect = options.reactiveRect
			rW = get(reactiveRect)[2]
			rH = get(reactiveRect)[3]
			paneHidden = false
			smoothDown = smoother(0)
			smoothDown2 = smoother(0)
			smoothPaneHidden = smoother(0)
			smoothXY = smoother2(nil, 0.5)
			smoothH = smoother(nil, 0)
			statePaneH = options.statePaneH
			prevStatePaneH = nil
			sm = 0 // disable smoothing the first frame	
			saveState = false
			dragHandlePos = self.getPosition()
			dragHandlePosSaved = self.getPosition()
			warpAtEdge = func x { mix(-8, 0, smoothstep(0, 30, x)) } // if bottom of rect is at y==0 : offset -8
			border = 4  // looks nicer if text is cut slightly earlier than bg 
			
			getPaneOffsetY = func { 
				h = rH
				offset = smoothPaneHidden.value * h
				warp = warpAtEdge(h - offset)
				return -floor(offset - warp)
			}

			self.bindDrawables([bg, icon], func {
				pos = smoothXY.value
				extraW = 20 // just to hide top rounded rect corners
				rectY = getPaneOffsetY() - extraW
				rectH = rH + extraW + border

				if options.iconData {
					iconData = options.iconData
					pts = []
					for i * len(iconData)/2 {
						push(pts, iconData[i*2] == nil ? nil :  iconData[i*2  ] * iconScale + pos[0])
						push(pts, iconData[i*2] == nil ? nil : -iconData[i*2+1] * iconScale + pos[1])
					}
					iconAmt = max(smoothPaneHidden.value, 1 - linearstep(0, 30, (rectY + rectH) - cornerPos[1]))
					if options.iconOpacity { iconAmt = iconAmt * options.iconOpacity }
					icon.update('shape', {points = pts, color = options.iconColor or '#fff', opacity = iconAmt})						
				}
			
				// rounded rect
				bgPts = roundedRectAndCircle(
						0, rectY, rW, rectH, 10,      // rounded rect
						pos[0], pos[1], 25 + 10 * smoothDown.value,  // circle
						5 + 10 * smoothDown2.value, 1)              // react distance, tesselation
				bg.update('shape', {points = bgPts, color = options.bgColor or '#222', opacity = options.bgOpacity ? options.bgOpacity : 0.8})

			})
						
			eachFrameUpdate = func dt {

				smoothDown      .process(self.isDown() ? 1 : 0, 0.05 * sm, dt)
				smoothDown2     .process(self.isDown() ? 1 : 0, 0.25 * sm, dt)
				smoothPaneHidden.process(paneHidden    ? 1 : 0, 0.55 * sm, dt)

				if self.isDown() {
					dragHandlePos = self.getPosition();
				}

				if options.changedFromCss and options.changedFromCss() {
					// rect changed via css (from user resize textarea or browser tools)
					rW = get(reactiveRect)[2]			
					dragHandlePos[1] = get(reactiveRect)[3] + circleVsBottomOffset	
				}

				if statePaneH and get(statePaneH) != prevStatePaneH {
					// from URL #pane
					paneHidden = get(statePaneH) < 0
					smoothPaneHidden.reset(paneHidden ? 1 : 0)
					saveState = false
					sm = 0
					dragHandlePos[1] = abs(get(statePaneH)) + circleVsBottomOffset
					prevStatePaneH = get(statePaneH)			
				}

				curY = get(reactiveRect)[1]
				curH = get(reactiveRect)[3]
				newH = curH
				if not paneHidden {
					newHps = max(0, dragHandlePos[1] - circleVsBottomOffset + warpAtEdge(dragHandlePos[1] - cornerPos[1]) * 8)
					// base smoothing amount on distance 
					heightSmoothTime = mix(0.3, 0.1, smoothH.value == nil ? 0 : smoothstep(40, 140, abs(newHps - smoothH.value)))
					newH = floor(smoothH.process(newHps, heightSmoothTime * sm, dt))
				}

				if options.changedFromPageResize and options.changedFromPageResize() {
					rW = get(reactiveRect)[2]	
				}
				
				if newH != curH or getPaneOffsetY() != curY or options.changedFromPageResize and options.changedFromPageResize() {
					rH = newH
					set(reactiveRect, [0, getPaneOffsetY(), rW, rH], self) 
					options.onChangedPane([0, getPaneOffsetY() + rH + border]) if options.onChangedPane // in future, use negative values to indicate bottom/right-pinned panes
					bg.needDraw()
				} 				

				if self.isDown() {
					smoothXY.process(dragHandlePos, 0.08 * sm, dt)
				} else {
					smoothXY.process(paneHidden ? cornerPos : dragHandlePos, 0.5 * sm, dt)
					self.setPosition(smoothXY.value)
				}

				if not (smoothDown.reached and smoothDown2.reached and
						smoothXY.reached and smoothPaneHidden.reached)
				{
					bg.needDraw()
				} else if statePaneH and saveState {
					prevStatePaneH = rH * (paneHidden ? -1 : 1)
					set(statePaneH, prevStatePaneH)	
					saveState = false
				}

				sm = 1
			}

//			options.createAnimationCallback( func dt {
			onInterval(0, func { eachFrameUpdate(frameDeltaTime()) })

			eachFrameUpdate(0) // initial update

			return {
				onMoved            = func { bg.needDraw() }
				onClicked          = func {
					if not options.clickEvent { 
						if paneHidden {
							dragHandlePos = dragHandlePosSaved
						} 
						if paneHidden or 
						   self.timeSinceOnDown() < 0.4 // holding down for long duration when not folded -> interpret as drag (don't hide)
						{   
							paneHidden = not paneHidden	
						}
						saveState = true						
					}
				}
				onDown = func {
					options.clickEvent() if options.clickEvent
					dragHandlePosSaved = dragHandlePos 
					bg.needDraw()
				} 
				onUp = func {
					saveState = true				
					bg.needDraw()
				}
				onDragBegin = func { 
					if paneHidden {
						paneHidden = false
						// started dragging the icon of a hidden pane
						// hard switch from: pane offseted -> pane is cropped
						smoothPaneHidden.reset(0)
						smoothH.reset(0)
					}
				}
				onDragEnd = func { 
					if not paneHidden {
						if self.getPosition()[1] - 40 <= cornerPos[1] {
							// dragged and released close to top, interpret as hide
							dragHandlePos = [cornerPos[0], options.defaultHeight or 300]
							paneHidden = true
							saveState = true
						}
					}
				}
			}
		}
	})

}
